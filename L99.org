#+title:  L-99: Ninety-Nine Lisp Problems
#+description: Based on a Prolog problem list by werner.hett@hti.bfh.ch
#+url: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/L-99_Ninety-Nine_Lisp_Problems.html

This is a org document which contains 99 lisp problems and their solutions.

* Start the game
** bootstrap
We use the great [[https://github.com/slime/slime][slime]] package for org babel evaluation, you can install it from MELPA with ~(package-install 'slime)~.

Evaluate the following code block to start an inferior lisp environment.

#+begin_src emacs-lisp :results output
  (require 'slime)
  (require 'ob-lisp)
  (setf (alist-get ':results org-babel-default-header-args:lisp) "value list raw")
  (slime)

  ;; by default, org babel use `slime-eval'
  ;; you should have `slime' installed
  ;; and make sure that you have correct `inferior-lisp-program' set to it.
  ;; (customize-set-variable 'org-babel-lisp-eval-fn #'slime-eval)

  (print "Hacker's Time!")
#+end_src

#+RESULTS:
: 
: "Hacker's Time!"

** How-to-play
~org-mode~ provides these key bindings:
- Press ~C-c C-,~ to create a code block to write your solution.
- Press ~C-c '~ on a code block to edit the code in that code block.
- Press ~C-c C-c~ to evaluate a code block and get result.
- Press ~S-<left>~ on a heading to switch it between ~TODO~ and ~DONE~ status.
- Press ~C-c C-o~ to open a link, press ~C-x SPC~ to jump back.

About usage of org code blocks, see more in [[info:org#Working with Source Code][org#Working with Source Code]].

I have left my solutions as well as testcases in ~:SOLUTION:~ section after each problem. If you need my suggestion or help, press ~TAB~ on ~:SOLUTION:~! Actually I am also not sure if I have solved all problems all correctly, so don't depend on these solutions and testcases too much!

Most simple problems are already solved on upstream site. You can check these alternative solutions at [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/L-99_Ninety-Nine_Lisp_Problems.html]] .

Other resources:
- [[https://github.com/meagtan/99-lisp-problems][solution of 99 lisp programs in common lisp (some out of date)]]
- [[https://picolisp.com/wiki/?99problems][99 picolisp programs (not complete)]]
- [[https://www.autistici.org/interzona/99-problems.html][99 lisp problems (not all solved)]]
- [[https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems][99 haskell problems]]

* Working with lists
** P01 (⋆) Find the last box of a list.
Example:
  (my-last '(a b c d))
(D)

:SOLUTION:
In Common Lisp, there is a built-in function ~last~, but it dosn't return a list.
#+begin_src lisp
  (defun my-last (l &aux (xs (cdr l)))
    (if xs (my-last xs) l))

  ;; test
  (mapcar
   #'my-last
   '(() (a) (a b) (a b c d)))
#+end_src

#+RESULTS:
- (NIL (A) (B) (D))

For a tail-recursive function, it is more natural to consider ~reduce~. Most problems in this section can be rewritten in this style, it may bring you a more functional programming style. Here is one example:
#+begin_src lisp
  (defun last-1 (l)
    (reduce (lambda (_ x) x) (cons nil l)))

  (defun my-last-1 (l)
    (and l (list (last-1 l))))

  ;; test
  (mapcar
   #'my-last-1
   '(() (a) (a b) (a b c d)))
#+end_src

#+RESULTS:
- (NIL (A) (B) (D))

:END:
** P02 (⋆) Find the last but one box of a list.
Example:
  (my-but-last '(a b c d))
(C D)

:SOLUTION:
In Common Lisp, there is a built-in function ~but-last~.
#+begin_src lisp
  (defun my-but-last (l &aux (xs (cdr l)))
    (if (cdr xs) (my-but-last xs) l))

  ;; test
  (mapcar
   #'my-but-last
   '(() (a) (a b) (a b c d)))
#+end_src

#+RESULTS:
- (NIL (A) (A B) (C D))

:END:
** P03 (⋆) Find the K'th element of a list.
The first element in the list is number 1.
Example:
  (element-at '(a b c d e) 3)
C

:SOLUTION:
In Common Lisp, there is a built-in function ~nth~ (which counts from 0).
#+begin_src lisp
  (defun element-at (l k)
    (cond
      ((> k 1) (element-at (cdr l) (1- k)))
      ((= k 1) (car l))))

  ;; test
  (let ((l '(a b c d e)))
    (mapcar
     (lambda (n) (funcall #'element-at l n))
     '(-1 0 3 5 6)))
#+end_src

#+RESULTS:
- (NIL NIL C E NIL)

:END:
** P04 (⋆) Find the number of elements of a list.

:SOLUTION:
In Common Lisp, there is a built-in function ~length~.
#+begin_src lisp
  (defun my-length (l)
    (if l (1+ (my-length (cdr l))) 0))

  ;; test
  (my-length '(a b c))
#+end_src

#+RESULTS:
- 3

:END:
** P05 (⋆) Reverse a list.

:SOLUTION:
In Common Lisp, there is a built-in function ~reverse~. Don't mess it with the destructive one ~nreverse~.

#+begin_src lisp
  (defun my-nreverse (l &optional r)
    (if l (my-nreverse (cdr l) (cons (car l) r)) r))

  (defun my-reverse (l)
    (my-nreverse (copy-list l)))

  ;; test
  (my-reverse '(a b c d))
#+end_src

#+RESULTS:
- (D C B A)

:END:
** P06 (⋆) Find out whether a list is a palindrome.
A palindrome can be read forward or backward; e.g. (x a m a x).

:SOLUTION:
This may be the simplest solution.
#+begin_src lisp
  (defun palindrome-p (l)
    (equal l (reverse l)))

  ;; test
  (list
   (palindrome-p '(x a m a x))
   (palindrome-p '(x a m b x)))
#+end_src

#+RESULTS:
- (T NIL)

:END:
** P07 (⋆⋆) Flatten a nested list structure.
Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively).

Example:
  (my-flatten '(a (b (c d) e)))
(A B C D E)

Hint: Use the predefined functions list and append.

:SOLUTION:
This is a very common operation in list manipulation, but no built-in for it.
#+begin_src lisp
  (defun my-flatten (l)
    (mapcan (lambda (a)
              (if (atom a)
                  (list a)
                  (my-flatten a)))
            l))

  ;; test
  (my-flatten '(a (b (c d) e)))
#+end_src

#+RESULTS:
- (A B C D E)

:END:
** P08 (⋆⋆) Eliminate consecutive duplicates of list elements.
If a list contains repeated elements they should be replaced with a single copy of the element. The order of the elements should not be changed.

Example:
  (compress '(a a a a b c c a a d e e e e))
(A B C A D E)

:SOLUTION:
#+begin_src lisp
  (defun compress (l &aux (x  (car l)) (xs (cdr l)))
    (unless (null l)
        (if (equal x (car xs))
            (compress xs)
            (cons x (compress xs)))
        ))

  ;; test
  (compress '(a a a a b c c a a d e e e e))
#+end_src

#+RESULTS:
- (A B C A D E)

:END:
** P09 (⋆⋆) Pack consecutive duplicates of list elements into sublists.
If a list contains repeated elements they should be placed in separate sublists.

Example:
  (pack '(a a a a b c c a a d e e e e))
((A A A A) (B) (C C) (A A) (D) (E E E E))

:SOLUTION:
#+begin_src lisp
  (defun pack (l &aux (x (car l)) (xs (cdr l)))
    (if (null xs)
        (list (list x))
        (let ((res (pack xs)))
          (if (equal x (car xs))
              (cons (cons x (car res)) (cdr res))
              (cons (list x) (pack xs)))
          )))
  ;; test
  (mapcar
   #'pack
   '(nil (a a a a) (a a a a b c c a a d e e e e)))
#+end_src

#+RESULTS:
- (((NIL)) ((A A A A)) ((A A A A) (B) (C C) (A A) (D) (E E E E)))

:END:
** P10 (⋆) Run-length encoding of a list.
Use the result of problem [[*P09 (⋆⋆) Pack consecutive duplicates of list elements into sublists.][P09]] to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists (N E) where N is the number of duplicates of the element E.

Example:
  (encode '(a a a a b c c a a d e e e e))
((4 A) (1 B) (2 C) (2 A) (1 D) (4 E))

:SOLUTION:
Use ~pack~ defined in P09
#+begin_src lisp
  (defun encode (l)
    (unless (null l)
      (mapcar (lambda (sl)
                  (list (length sl) (car sl)))
              (pack l))))

  ;; test
  (list
   (encode nil)
   (encode '(a a a a b c c a a d e e e e)))
#+end_src

#+RESULTS:
- (NIL ((4 A) (1 B) (2 C) (2 A) (1 D) (4 E)))

:END:
** P11 (⋆) Modified run-length encoding.
Modify the result of problem [[*P10 (⋆) Run-length encoding of a list.][P10]] in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as (N E) lists.

Example:
  (encode-modified '(a a a a b c c a a d e e e e))
((4 A) B (2 C) (2 A) D (4 E))

:SOLUTION:
Use ~encode~ defined in [[*P10 (⋆) Run-length encoding of a list.][P10]].
#+begin_src lisp
  (defun encode-modified (l)
    (mapcar (lambda (pair)
                (if (= 1 (car pair)) (cadr pair) pair))
            (encode l)))

  ;; test
  (list
     (encode-modified nil)
     (encode-modified '(a a a a b c c a a d e e e e)))
#+end_src

#+RESULTS:
- (NIL ((4 A) B (2 C) (2 A) D (4 E)))

:END:
** P12 (⋆⋆) Decode a run-length encoded list.
Given a run-length code list generated as specified in problem [[*P11 (⋆) Modified run-length encoding.][P11]]. Construct its uncompressed version.

:SOLUTION:
Here we define a function ~repeat~, which are useful.
#+begin_src lisp
  (defun repeat (n x)
    (unless (<= n 0)
      (cons x (repeat (1- n) x))))

  (defun decode (l)
    (mapcan (lambda (sl)
              (if (atom sl)
                  (list sl)
                  (apply #'repeat sl)))
            l))

  ;; test
  (decode '((4 A) B (2 C) (2 A) D (4 E)))
#+end_src

#+RESULTS:
- (A A A A B C C A A D E E E E)

:END:
** P13 (⋆⋆) Run-length encoding of a list (direct solution).
Implement the so-called run-length encoding data compression method directly. I.e. don't explicitly create the sublists containing the duplicates, as in problem P09, but only count them. As in problem P11, simplify the result list by replacing the singleton lists (1 X) by X.

Example:
  (encode-direct '(a a a a b c c a a d e e e e))
((4 A) B (2 C) (2 A) D (4 E))

:SOLUTION:
#+begin_src lisp
  (defun encode-direct (l &aux (x (car l)) (xs (cdr l)))
    (if (null xs)
        (list x)
        (let ((res (encode-direct xs)))
          (cond ((and (atom (car res))
                      (equal x (car xs)))
                 (cons (list 2 x) (cdr res)))
                ((equal (cadr x) (car xs))
                 (cons (list (1+ (car x)) (cadr x))
                       (cdr res)))
                (t (cons x (cdr res))))
        )))

  ;; test
  (list (encode-modified nil)
        (encode-modified '(a a a a b c c a a d e e e e)))
#+end_src

#+RESULTS:
- (NIL ((4 A) B (2 C) (2 A) D (4 E)))

:END:
** P14 (⋆) Duplicate the elements of a list.
Example:
  (dupli '(a b c c d))
(A A B B C C C C D D)

:SOLUTION:
#+begin_src lisp
  (defun dupli (l)
    (mapcan (lambda (x) (list x x)) l))

  ;; test
  (dupli '(a b c c d))
#+end_src

#+RESULTS:
- (A A B B C C C C D D)

:END:
** P15 (⋆⋆) Replicate the elements of a list a given number of times.
Example:
  (repli '(a b c) 3)
(A A A B B B C C C)

:SOLUTION:
Here we reuse function ~repeat~ implemented in [[*P12 (⋆⋆) Decode a run-length encoded list.][P12]].
#+begin_src lisp
  (defun repli (l n)
    (mapcan (lambda (x) (repeat n x)) l))

  ;; test
  (repli '(a b c) 3)
#+end_src

#+RESULTS:
- (A A A B B B C C C)

:END:
** P16 (⋆⋆) Drop every N'th element from a list.
Example:
  (drop '(a b c d e f g h i k) 3)
(A B D E G H K)

:SOLUTION:
Here I use built-in function ~nthcdr~ plus another function ~concar~.
- ~concar~ takes all elements before ~n~.
- ~nthcdr~ takes all elements after ~n~.

Note that ~nthcdr~ is not destructive, it returns a copy, just like ~concar~.

#+begin_src lisp
  (defun concar (n l)
    (unless (or (<= n 0) (null l))
      (cons (car l) (concar (1- n) (cdr l)))))

  (defun drop (l n)
    (unless (null l)
      (append (concar (1- n) l)
              (drop (nthcdr n l) n))))

  ;; test
  (drop '(a b c d e f g h i k) 3)
#+end_src

#+RESULTS:
- (A B D E G H K)

:END:
** P17 (⋆) Split a list into two parts; the length of the first part is given.
Do not use any predefined functions.

Example:
  (split '(a b c d e f g h i k) 3)
((A B C) (D E F G H I K))

:SOLUTION:
Here we reuse ~concar~ defined in [[*P16 (⋆⋆) Drop every N'th element from a list.][P16]] and show that ~nthcdr~ can be easily implemented with the same manner.
#+begin_src lisp
  (defun my-nthcdr (n l)
    (if (or (<= n 0) (null l))
        l
        (my-nthcdr (1- n) (cdr l))))

  (defun split (l n)
    (list (concar n l) (my-nthcdr n l)))

  ;; test
  (split '(a b c d e f g h i k) 3)
#+end_src

#+RESULTS:
- ((A B C) (D E F G H I K))

:END:
** P18 (⋆⋆) Extract a slice from a list.
Given two indices, I and K, the slice is the list containing the elements between the I'th and K'th element of the original list (both limits included). Start counting the elements with 1.

Example:
  (slice '(a b c d e f g h i k) 3 7)
(C D E F G)

:SOLUTION:
Using ~concar~ defined in [[*P16 (⋆⋆) Drop every N'th element from a list.][P16]].
#+begin_src lisp
  (defun slice (l i k)
    (when (> k 0)
      (let ((j (if (<= i 0) 1 i)))
        (cons (nth (1- j) l)
              (concar (- k j) (nthcdr j l))))))

  ;; test
  (let ((l '(a b c d e f g h i k)))
    (list
     (slice l 3 7)
     (slice l -3 0)
     (slice l 7 16)
     (slice l -3 7)
     ))
#+end_src

#+RESULTS:
- ((C D E F G) NIL (G H I K) (A B C D E F G))

:END:
** P19 (⋆⋆) Rotate a list N places to the left.
Examples:
  (rotate '(a b c d e f g h) 3)
(D E F G H A B C)

  (rotate '(a b c d e f g h) -2)
(G H A B C D E F)

Hint: Use ~split~ defined in [[*P17 (⋆) Split a list into two parts; the length of the first part is given.][P17]].

:SOLUTION:
Following hint.
#+begin_src lisp
  (defun rotate (l n &aux (len (length l)))
    (cond
      ((< n 0) (rotate l (+ len (mod n len))))
      ((> n len) (rotate l (mod n len)))
      (t (let ((parts (split l n)))
           (append (cadr parts) (car parts))))))

  ;; test
  (let ((l '(a b c d e f g h)))
    (list
     (rotate l 3)
     (rotate l 8)
     (rotate l -2)
     ))
#+end_src

#+RESULTS:
- ((D E F G H A B C) (A B C D E F G H) (G H A B C D E F))

:END:
** P20 (⋆) Remove the K'th element from a list.
Example:
  (remove-at '(a b c d) 2)
(A C D)

:SOLUTION:
In Common Lisp, there is a built-in function ~remove~ .

Here using ~concar~ defined in [[*P16 (⋆⋆) Drop every N'th element from a list.][P16]].
#+begin_src lisp
  (defun remove-at (l k)
    (if (and (> k 0) (<= k (length l)))
        (append (concar (1- k) l) (nthcdr k l))
        l))

  ;; test
  (remove-at '(a b c d) 2)
#+end_src

#+RESULTS:
- (A C D)

:END:
** P21 (⋆) Insert an element at a given position into a list.
Example:
  (insert-at 'alfa '(a b c d) 2)
(A ALFA B C D)

:SOLUTION:
Amazing that there is no built-in function named ~insert~ .
Here using ~concar~ defined in [[*P16 (⋆⋆) Drop every N'th element from a list.][P16]].
#+begin_src lisp
  (defun insert-at (item l pos)
    (append (concar (1- pos) l)
            (list item)
            (nthcdr (1- pos) l)))

  ;; test
  (list
   (insert-at 'alfa '(a b c d) 1)
   (insert-at 'alfa '(a b c d) 2)
   (insert-at 'alfa '(a b c d) 5)
   )
#+end_src

#+RESULTS:
- ((ALFA A B C D) (A ALFA B C D) (A B C D ALFA))

:END:
** P22 (⋆) Create a list containing all integers within a given range.
If first argument is smaller than second, produce a list in decreasing order.
Example:
  (range 4 9)
(4 5 6 7 8 9)

:SOLUTION:
This would be ugly if you want the case of ~(= start end)~ to be ~nil~.
#+begin_src lisp
  (defun range (start end)
    (when (<= start end)
      (cons start
            (range (1+ start) end))))

  ;; test
  (list
   (range 4 4)
   (range 4 5)
   (range 4 9))
#+end_src

#+RESULTS:
- ((4) (4 5) (4 5 6 7 8 9))

:END:
** P23 (⋆⋆) Extract a given number of randomly selected elements from a list.
The selected items shall be returned in a list.
Example:
  (rnd-select '(a b c d e f g h) 3)
(E D A)

Hint: Use the built-in random number generator and the result of problem P20.

:SOLUTION:
A serious problem is that whether duplicates are allowed.
If duplicates are allowed, then this problem seems to be too simple.
If not, we may remove the last selected element (using ~remove-at~ from [[*P20 (⋆) Remove the K'th element from a list.][P20]]).

Here is the implementation of the latter idea, but using built-in ~remove~.
#+begin_src lisp
  (defun rnd-select (l n &aux (x (nth (random (length l)) l)))
    (cons x (unless (= 1 n) (rnd-select (remove x l) (1- n))))))

  ;; test
  (rnd-select '(a b c d e f g h) 3)
#+end_src

#+RESULTS:
- (E H B)

:END:
** P24 (⋆) Lotto: Draw N different random numbers from the set 1..M.
The selected numbers shall be returned in a list.
Example:
  (lotto-select 6 49)
(23 1 17 33 21 37)

Hint: Combine the solutions of problems P22 and P23.

:SOLUTION: following the hint, use ~range~ from [[*P22 (⋆) Create a list containing all integers within a given range.][P22]] and ~rnd-select~ from [[*P23 (⋆⋆) Extract a given number of randomly selected elements from a list.][P23]].
#+begin_src lisp
  (defun lotto-select (n m)
    (rnd-select (range 1 m) n))

  (lotto-select 6 49)
#+end_src

#+RESULTS:
- (45 32 6 36 48 39)

:END:
** P25 (⋆) Generate a random permutation of the elements of a list.
Example:
  (rnd-permu '(a b c d e f))
(B A D C E F)

Hint: Use the solution of problem P23.

:SOLUTION:
Following the hint, use ~rnd-select~ from [[*P23 (⋆⋆) Extract a given number of randomly selected elements from a list.][P23]].
#+begin_src lisp
  (defun rnd-permu (l)
    (rnd-select l (length l)))

  ;; test
  (rnd-permu '(a b c d e f))
#+end_src

#+RESULTS:
- (C A F B E D)

:END:
** P26 (⋆⋆) Generate the combinations of K distinct objects chosen from the N elements of a list
In how many ways can a committee of 3 be chosen from a group of 12 people? We all know that there are C(12,3) = 220 possibilities (C(N,K) denotes the well-known binomial coefficients). For pure mathematicians, this result may be great. But we want to really generate all the possibilities in a list.

Example:
  (combination 3 '(a b c d e f))
((A B C) (A B D) (A B E) ... )

:SOLUTION:
Note that C(n, k) = C(n-1, k) + C(n-1, k-1) = C(n-1, k) + C(n-2, k-1) + ... + C(n-k, 1)
#+begin_src lisp
  (defun combination (k l)
    (cond
      ((null l) nil)
      ((= k 0) (list nil))
      ((= k 1) (mapcar (lambda (x) (list x)) l))
      (t (append
          (mapcar (lambda (x) (cons (car l) x))
                  (combination (1- k) (cdr l)))
          (combination k (cdr l))
          ))))

  ;; test
  (mapcar
   (lambda (args) (apply #'combination args))
   (list
    '(0 (a b c))
    '(1 nil)
    '(1 (a))
    '(1 (a b c))
    '(3 (a b c))
    '(3 (a b c d e f))))
#+end_src

#+RESULTS:
- ((NIL) NIL ((A)) ((A) (B) (C)) ((A B C))
- ((A B C) (A B D) (A B E) (A B F) (A C D) (A C E) (A C F) (A D E) (A D F)
- (A E F) (B C D) (B C E) (B C F) (B D E) (B D F) (B E F) (C D E) (C D F)
- (C E F) (D E F)))

:END:
** P27 (⋆⋆) Group the elements of a set into disjoint subsets.
a) In how many ways can a group of 9 people work in 3 disjoint subgroups of 2, 3 and 4 persons? Write a function that generates all the possibilities and returns them in a list.

Example:
  (group3 '(aldo beat carla david evi flip gary hugo ida))
( ( (ALDO BEAT) (CARLA DAVID EVI) (FLIP GARY HUGO IDA) )
... )

b) Generalize the above function in a way that we can specify a list of group sizes and the function will return a list of groups.

Example:
  (group '(aldo beat carla david evi flip gary hugo ida) '(2 2 5))
( ( (ALDO BEAT) (CARLA DAVID) (EVI FLIP GARY HUGO IDA) )
... )

Note that we do not want permutations of the group members; i.e. ((ALDO BEAT) ...) is the same solution as ((BEAT ALDO) ...). However, we make a difference between ((ALDO BEAT) (CARLA DAVID) ...) and ((CARLA DAVID) (ALDO BEAT) ...).

You may find more about this combinatorial problem in a good book on discrete mathematics under the term "multinomial coefficients".

:SOLUTION:
Using ~combination~ in [[*P26 (⋆⋆) Generate the combinations of K distinct objects chosen from the N elements of a list][P26]], here we only implement b) since a) is just a special case of b).

Here we use a powerful built-in function ~set-difference~, which find elements in the first list but not in the second list. It is also easy to implement.
#+begin_src lisp
  (defun my-set-difference (a b)
    (when a
      (let ((x (car a))
            (xs (my-set-difference (cdr a) b)))
        (if (member a b) xs (cons x xs)))))

  (defun group (l s)
    (if (null (cdr s))
        (list (list l))
        (mapcan
         (lambda (x)
           (mapcar
            (lambda (y)
              (cons x y))
            (group (set-difference l x) (cdr s))))
         (combination (car s) l))))

  ;; test
  (group '(aldo beat carla david evi flip) '(2 1 3))
#+end_src

#+RESULTS:
- (((ALDO BEAT) (FLIP) (CARLA DAVID EVI)) ((ALDO BEAT) (EVI) (CARLA DAVID FLIP))
- ((ALDO BEAT) (DAVID) (CARLA EVI FLIP)) ((ALDO CARLA) (FLIP) (BEAT DAVID EVI))
- ((ALDO CARLA) (EVI) (BEAT DAVID FLIP)) ((ALDO CARLA) (DAVID) (BEAT EVI FLIP))
- ((ALDO DAVID) (FLIP) (BEAT CARLA EVI)) ((ALDO DAVID) (EVI) (BEAT CARLA FLIP))
- ((ALDO DAVID) (CARLA) (BEAT EVI FLIP)) ((ALDO EVI) (FLIP) (BEAT CARLA DAVID))
- ((ALDO EVI) (DAVID) (BEAT CARLA FLIP)) ((ALDO EVI) (CARLA) (BEAT DAVID FLIP))
- ((BEAT CARLA) (FLIP) (ALDO DAVID EVI)) ((BEAT CARLA) (EVI) (ALDO DAVID FLIP))
- ((BEAT CARLA) (DAVID) (ALDO EVI FLIP)) ((BEAT DAVID) (FLIP) (ALDO CARLA EVI))
- ((BEAT DAVID) (EVI) (ALDO CARLA FLIP)) ((BEAT DAVID) (CARLA) (ALDO EVI FLIP))
- ((BEAT EVI) (FLIP) (ALDO CARLA DAVID)) ((BEAT EVI) (DAVID) (ALDO CARLA FLIP))
- ((BEAT EVI) (CARLA) (ALDO DAVID FLIP)) ((CARLA DAVID) (FLIP) (ALDO BEAT EVI))
- ((CARLA DAVID) (EVI) (ALDO BEAT FLIP)) ((CARLA DAVID) (BEAT) (ALDO EVI FLIP))
- ((CARLA EVI) (FLIP) (ALDO BEAT DAVID)) ((CARLA EVI) (DAVID) (ALDO BEAT FLIP))
- ((CARLA EVI) (BEAT) (ALDO DAVID FLIP)) ((DAVID EVI) (FLIP) (ALDO BEAT CARLA))
- ((DAVID EVI) (CARLA) (ALDO BEAT FLIP)) ((DAVID EVI) (BEAT) (ALDO CARLA FLIP)))

:END:
** P28 (⋆⋆) Sorting a list of lists according to length of sublists
a) We suppose that a list contains elements that are lists themselves. The objective is to sort the elements of this list according to their length. E.g. short lists first, longer lists later, or vice versa.

Example:
  (lsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))

b) Again, we suppose that a list contains elements that are lists themselves. But this time the objective is to sort the elements of this list according to their length frequency; i.e., in the default, where sorting is done ascendingly, lists with rare lengths are placed first, others with a more frequent length come later.

Example:
  (lfsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
((I J K L) (O) (A B C) (F G H) (D E) (D E) (M N))

Note that in the above example, the first two lists in the result have length 4 and 1, both lengths appear just once. The third and forth list have length 3 which appears twice (there are two list of this length). And finally, the last three lists have length 2. This is the most frequent length.

:SOLUTION:
a) using built-in function ~sort~.
#+begin_src lisp
  (defun lsort (l)
    (sort l (lambda (a b) (< (length a) (length b)))))

  ;; test
  (lsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
#+end_src

#+RESULTS:
- ((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))

If we want to implement a sort function of our own, quicksort will be a nice one:

Here we use ~values~ and ~multiple-value-bind~ to return and receive multiple values, however, it is usually simpler to return a list of values and analyze it to receive.
#+begin_src lisp
  (defun bipart (pred l)
    (let ((t-list '())
          (f-list '()))
      (mapc (lambda (item)
              (if (funcall pred item)
                  (push item t-list)
                  (push item f-list)))
            l)
      (values (nreverse t-list)
              (nreverse f-list))))

  ;; using quicksort
  (defun qsort (l pred &aux (pivot (car l)) (r (cdr l)))
    (cond
      ((null l) nil)
      ((null r) l)
      (t (multiple-value-bind (left right)
             (bipart (lambda (item) (funcall pred item pivot)) r)
           (nconc (qsort left pred)
                  (list pivot)
                  (qsort right pred))))))

  (defun lsort (l)
    (qsort l (lambda (a b) (< (length a) (length b)))))

  ;; test
  (lsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
#+end_src

#+RESULTS:
- ((O) (D E) (D E) (M N) (A B C) (F G H) (I J K L))

b) use a slighty modified version of function ~pack~ defined in P09.
#+begin_src lisp
  (defun pack-modified (l &aux (x (car l)) (xs (cdr l)))
    (if (null xs)
        (list (list x))
        (let ((res (pack-modified xs)))
          (if (= (length x) (length (car xs))) ; pack by length
              (cons (cons x (car res)) (cdr res))
              (cons (list x) (pack xs)))
          )))

  (defun lfsort (l)
    (apply #'append (lsort (pack-modified (lsort l)))))

  ;; test
  (lfsort '((a b c) (d e) (f g h) (d e) (i j k l) (m n) (o)))
#+end_src

#+RESULTS:
- ((O) (I J K L) (F G H) (A B C) (M N) (D E) (D E))

:END:
* Arithmetic
** P31 (⋆⋆) Determine whether a given integer number is prime.
Example:
  (is-prime 7)
T

:SOLUTION:
Lisp doesn't allow early break in ~mapcar~, so we implement it with the powerful ~loop~ macro. It is a little bit horrible that in fact ~loop~ is a macro. Afaik, MacLisp use tags in ~prog~ block and ~(go TAG)~ to achieve such a control style, which provides transparent low level control flow. Common Lisp's ~loop~ encapsules the same thing with automatically generated tags, at least it's clearer and safer, most of the time. If you want to figure out how this macro works, read the expanded code.

~loop~ provides very sophisticated control grammar, which can fully cover those high level functions, like ~mapcar~, ~dotimes~, ~reduce~, ~find~, ~some~, ~every~, ~remove-if~. It is to some degree more sophisticated than Lisp itself. After all, Lisp doesn't have a built-in array processing component which is as powerful as its list processing abilities, and the control flow is actually about how to interpreting an array of instructions, rather than a list. You will see how I abuse ~loop~ macro in solutions of following problems.

~isqrt~ is another builtin for integer square root.
#+begin_src lisp
  (defun is-prime (n)
    (when (< 1 n) ; 1 is not prime
      (loop for i from 2 to (isqrt n)
            never (zerop (mod n i)))))

  ;; test
  (mapcar #'is-prime '(1 2 4 7))
#+end_src

#+RESULTS:
- (NIL T NIL T)

This is equivalent to:
#+begin_src lisp
  (defun is-prime-1 (n)
    (when (< 1 n) ; 1 is not prime
      (every (lambda (i) (not (zerop (mod n i))))
             (range 2 (isqrt n)))))

  ;; test
  (mapcar #'is-prime-1 '(1 2 4 7))
#+end_src

#+RESULTS:
- (NIL T NIL T)

:END:
** P32 (⋆⋆) Determine the greatest common divisor of two positive integer numbers.
Use Euclid's algorithm.
Example:
  (my-gcd 36 63)
9

:SOLUTION:
In Common Lisp, there is a built-in function ~gcd~ .

#+begin_src lisp
  (defun my-gcd (x y)
    (cond
      ((< x y) (my-gcd y x))
      ((zerop y) x)
      (t (my-gcd y (mod x y)))))

  ;; test
  (my-gcd 36 63)
#+end_src

#+RESULTS:
- 9

:END:
** P33 (⋆) Determine whether two positive integer numbers are coprime.
Two numbers are coprime if their greatest common divisor equals 1.
Example:
  (coprime 35 64)
T

:SOLUTION:
A direct solution uses ~gcd~ directly, but, actually, this problem is no easier than ~gcd~.
#+begin_src lisp
  (defun coprime (x y)
    (= 1 (gcd x y)))

  ;; test
  (list
   (coprime 1 1)
   (coprime 1 35)
   (coprime 35 64)
   (coprime 36 64))
#+end_src

#+RESULTS:
- (T T T NIL)

:END:
** P34 (⋆⋆) Calculate Euler's totient function phi(m).
Euler's so-called totient function phi(m) is defined as the number of positive integers r (1 <= r < m) that are coprime to m.
Example: m = 10: r = 1,3,7,9; thus phi(m) = 4. Note the special case: phi(1) = 1.

  (totient-phi 10)
4

Find out what the value of phi(m) is if m is a prime number. Euler's totient function plays an important role in one of the most widely used public key cryptography methods (RSA). In this exercise you should use the most primitive method to calculate this function (there are smarter ways that we shall discuss later).

:SOLUTION:
Note that, the value of phi(m) is always m-1 if m is a prime number.
Use ~coprime~ defined in [[*P33 (⋆) Determine whether two positive integer numbers are coprime.][P33]]

#+begin_src lisp
  (defun totient-phi (n)
    (if (= 1 n)
        1
        (loop for i from 1 to (1- n)
              count (coprime i n))))

  ;; test
  (mapcar #'totient-phi '(1 10 315 317))
#+end_src

#+RESULTS:
- (1 4 144 316)

:END:
** P35 (⋆⋆) Determine the prime factors of a given positive integer.
Construct a flat list containing the prime factors in ascending order.
Example:
  (prime-factors 315)
(3 3 5 7)

:SOLUTION:
We use a loop for divisor detection.
#+begin_src lisp
  (defun prime-factors-aux (n begin end)
    (let ((d (loop for i from begin to end
                   when (zerop (mod n i))
                   return i
                   finally (return n))))
      (when (> d 1)
        (cons d (prime-factors-aux (/ n d) d end)))))

  (defun prime-factors (n)
    (prime-factors-aux n 2 (isqrt n)))

  ;; test
  (mapcar #'prime-factors
          '(1 2 4 315 316 317))
#+end_src

#+RESULTS:
- (NIL (2) (2 2) (3 3 5 7) (2 2 79) (317))

:END:
** P36 (⋆⋆) Determine the prime factors of a given positive integer (2).
Construct a list containing the prime factors and their multiplicity.
Example:
  (prime-factors-mult 315)
((3 2) (5 1) (7 1))
Hint: The problem is similar to problem P10.

:SOLUTION:
following the hint, using ~encode~ from [[*P10 (⋆) Run-length encoding of a list.][P10]].
#+begin_src lisp
  (defun prime-factors-mult (n)
    (mapcar #'reverse (encode (prime-factors n))))

  ;; test
  (mapcar
   #'prime-factors-mult
   '(1 315 316 317))
#+end_src

#+RESULTS:
- (NIL ((3 2) (5 1) (7 1)) ((2 2) (79 1)) ((317 1)))

:END:
** P37 (⋆⋆) Calculate Euler's totient function phi(m) (improved).
See problem P34 for the definition of Euler's totient function. If the list of the prime factors of a number m is known in the form of problem P36 then the function phi(m) can be efficiently calculated as follows: Let ((p1 m1) (p2 m2) (p3 m3) ...) be the list of prime factors (and their multiplicities) of a given number m. Then phi(m) can be calculated with the following formula:
phi(m) = (p1 - 1) * p1 ** (m1 - 1) * (p2 - 1) * p2 ** (m2 - 1) * (p3 - 1) * p3 ** (m3 - 1) * ...

Note that a ** b stands for the b'th power of a.

:SOLUTION:
~*~ itself is recursive, so we do not need a ~reduce~ here.
#+begin_src lisp
  (defun totient-phi-1 (n)
    (apply #'*
           (mapcar (lambda (a &aux (p (car a)) (m (cadr a)))
                       (* (1- p) (expt p (1- m))))
                   (prime-factors-mult n))))

  ;; test
  (mapcar
   #'totient-phi-1
   '(1 10 315 317))
#+end_src

#+RESULTS:
- (1 4 144 316)

:END:
** P38 (⋆) Compare the two methods of calculating Euler's totient function.
Use the solutions of problems P34 and P37 to compare the algorithms. Take the number of basic operations, including CARs, CDRs, CONSes, and arithmetic operations, as a measure for efficiency. Try to calculate phi(10090) as an example.

:SOLUTION:
How to measure the running efficiency? This depends on the Common Lisp implementation you use. Here I use Steel Bank Common Lisp (SBCL).

In /SBCL User Manual/ chapter 16 introduced functions for profiling a program. However, it does not provide a direct solution to count how many times a function is called (because that is nonsense, you do not know how that function will be compiled, after all). Here I will use function ~time~ for simple profiling.

#+begin_src lisp
  (defun compare-totient-phi (n)
    (list
     (time (totient-phi   n))
     (time (totient-phi-1 n))))

  ;; result values should be the same, as for time
  ;; you can see the output in slime repl.
  (compare-totient-phi 10090)
#+end_src

#+RESULTS:
- (4032 4032)

:END:
** P39 (⋆) A list of prime numbers.
Given a range of integers by its lower and upper limit, construct a list of all prime numbers in that range.

:SOLUTION:
using ~range~ in [[*P22 (⋆) Create a list containing all integers within a given range.][P22]] and ~is-prime~ in [[*P31 (⋆⋆) Determine whether a given integer number is prime.][P31]]:
#+begin_src lisp
  (defun search-prime (start end)
    (mapcan (lambda (x) (when (is-prime x) (list x)))
            (range start end)))

  ;; test
  (search-prime 4 29)
#+end_src

#+RESULTS:
- (5 7 11 13 17 19 23 29)

Or, use ~loop collect~ for an iterative-style program:
#+begin_src lisp
  (defun search-prime-1 (start end)
    (loop for i from start to end
          when (is-prime i)
          collect i))

  ;; test
  (search-prime-1 4 29)
#+end_src

#+RESULTS:
- (5 7 11 13 17 19 23 29)

There is a more efficient algorithm, during each cycle we tested each number with ~is-prime~, and we know that actually we only need to test primes. So, if we firstly find out all primes between ~2~ and ~(isqrt N)~, we can eliminate a lot of tests. Then recursion can be done on ~(isqrt N)~. The complexity of this recursive algorithm is O(N log log N), which is better than original simple algorithm of O(N log N)

#+begin_src lisp
  (defun search-prime-2-aux (n)
    (if (< 2 n)
        (let* ((m (max 2 (isqrt n)))
               (primes (search-prime-2-aux m)))
          (nconc primes
                 (loop for i from m to n
                       when
                       (loop for j in primes
                             never (zerop (mod i j)))
                       collect i)))
        '(2)))

  (defun search-prime-2 (start end)
    (let* ((b (max 2 (isqrt end)))
           (primes (search-prime-2-aux b)))
      (nconc
       (when (<= start b)
         (loop for i in primes
               when (<= start i) collect i))
       (loop for i from (max start b) to end
             when
             (loop for j in primes
                   never (zerop (mod i j)))
             collect i))))

  ;; test and compare efficiency
  (equal
   (time (search-prime-1 90000 100000))
   (time (search-prime-2 90000 100000)))
#+end_src

#+RESULTS:
- T

:END:
** P40 (⋆⋆) Goldbach's conjecture.
Goldbach's conjecture says that every positive even number greater than 2 is the sum of two prime numbers. Example: 28 = 5 + 23. It is one of the most famous facts in number theory that has not been proved to be correct in the general case. It has been numerically confirmed up to very large numbers (much larger than we can go with our Lisp system). Write a function to find the two prime numbers that sum up to a given even integer.
Example:
  (goldbach 28)
(5 23)

:SOLUTION:
Use ~is-prime~ in [[*P31 (⋆⋆) Determine whether a given integer number is prime.][P31]], simply a brute-force search.
#+begin_src lisp
  (defun goldbach (n)
    (loop for i from 2 to (/ (1+ n) 2)
          when (and (is-prime i) (is-prime (- n i)))
            return (list i (- n i))))

  ;; test
  (list
   (goldbach 28)
   (goldbach 29))
#+end_src

#+RESULTS:
- ((5 23) NIL)

Note that, with ~search-prime-2~ implemented in [[*P39 (⋆) A list of prime numbers.][P39]], we can optimize this function.

#+begin_src lisp
  (defun goldbach-1 (n)
    (let ((primes (search-prime-2 2 n)))
      (loop for i in primes
            never (> i (/ (1+ n) 2))
            when (member (- n i) primes)
              return (list i (- n i)))))

  ;; test
  (list
   (goldbach-1 28)
   (goldbach-1 29))
#+end_src

#+RESULTS:
- ((5 23) NIL)

:END:
** P41 (⋆⋆) A list of Goldbach compositions.
Given a range of integers by its lower and upper limit, print a list of all even numbers and their Goldbach composition.
Example:
  (goldbach-list 9 20)
10 = 3 + 7
12 = 5 + 7
14 = 3 + 11
16 = 3 + 13
18 = 5 + 13
20 = 3 + 17

In most cases, if an even number is written as the sum of two prime numbers, one of them is very small. Very rarely, the primes are both bigger than say 50. Try to find out how many such cases there are in the range 2..3000.

Example (for a print limit of 50):
  (goldbach-list 1 2000 50)
992 = 73 + 919
1382 = 61 + 1321
1856 = 67 + 1789
1928 = 61 + 1867

:SOLUTION:
Note that the pair is not unique, actually such cases are not rare at all.
That means, actually we are finding the minimal prime accross all decompositions.

Use ~goldbach~ from [[*P40 (⋆⋆) Goldbach's conjecture.][P40]]
#+begin_src lisp :results output
  (defun goldbach-list (start end &optional (limit 0))
    (loop for i
          from (max 4 (+ start (mod start 2)))
          to   (- end (mod end 2))
          by 2
          for pair = (goldbach i)
          when (> (car pair) limit)
          do (format t "~%~d = ~d + ~d"
                     i (car pair) (cadr pair))))

  ;; test
  (goldbach-list 2 3000 50)
#+end_src

#+RESULTS:
- 992 = 73 + 919
- 1382 = 61 + 1321
- 1856 = 67 + 1789
- 1928 = 61 + 1867
- 2078 = 61 + 2017
- 2438 = 61 + 2377
- 2512 = 53 + 2459
- 2530 = 53 + 2477
- 2618 = 61 + 2557
- 2642 = 103 + 2539

This function can also be optimized with ~search-prime-2~ in [[*P39 (⋆) A list of prime numbers.][P39]], which can calculate all primes in ~(start end)~ at once.

:END:
* Logic and Codes
** P46 (⋆⋆) Truth tables for logical expressions.
Define functions and, or, nand, nor, xor, impl and equ (for logical equivalence) which return the result of the respective operation on boolean values.
A logical expression in two variables can then be written in prefix notation, as in the following example: (and (or A B) (nand A B)).

Write a function table which prints the truth table of a given logical expression in two variables.

Example:
  (table 'A 'B '(and A (or A B))).
true true true
true nil true
nil true nil
nil nil nil

:SOLUTION:
Since there are builtin logic functions, just replace the variable binding for symbol A and B.
Here we use backquote expression for constructing lexical bindings.
#+begin_src lisp :results output
  ;; and, or, not are built-in
  (defun nand (a b) (not (and a b)))
  (defun nor (a b) (not (or a b)))
  (defun xor (a b) (if a (not b) b))
  (defun equ (a b) (if a b (not b)))
  (defun impl (a b) (if a b t))

  (defun table (a b exp)
    (mapcar
     (lambda (cell)
         (format t "~:[nil~:;true~] ~:[nil~:;true~] ~:[nil~:;true~]~%"
                 (car cell) (cadr cell) (caddr cell)))
     (mapcan
      (lambda (x)
          (mapcar
           (lambda (y)
               (list x y (eval `(let ((,a ,x) (,b ,y)) ,exp))))
           '(t nil)))
      '(t nil))))

  ;; test
  (table 'A 'B '(and A (or A B)))
#+end_src

#+RESULTS:
- true true true
- true nil true
- nil true nil
- nil nil nil

:END:
** P47 (⋆) Truth tables for logical expressions (2).
Modify problem P46 by accepting expressions written in infix notation, with all parenthesis present. This allows us to write logical expression in a more natural way, as in the example: (A and (A or (not B))).
Example:
  (table 'A 'B '(A and (A or (not B)))).
true true true
true nil true
nil true nil
nil nil nil

:SOLUTION:
We can play a trick to reuse ~table~ defined in [[*P46 (⋆⋆) Truth tables for logical expressions.][P46]], by convert infix expression to prefix expression.
#+begin_src lisp :results output
  (defun flip (l)
    (cond
      ((atom l) l)
      ((null (cddr l))
       (list (car l) (flip (cadr l))))
      (t
       (list (flip (cadr l))
             (flip (car l))
             (flip (caddr l))))))

  (defun table-infix (a b exp)
    (table a b (flip exp)))

  ;; test
  (table-infix 'A 'B '(A and (A or (not B))))
#+end_src

#+RESULTS:
- true true true
- true nil true
- nil true nil
- nil nil nil

:END:
** P48 (⋆⋆) Truth tables for logical expressions (3).
Generalize problem P47 in such a way that the logical expression may contain any number of logical variables. Define table in a way that (table List Expr) prints the truth table for the expression Expr, which contains the logical variables enumerated in List.
Example:
  (table '(A B C) '((A and (B or C)) equ ((A and B) or (A and C)))).
true true true true
true true nil true
true nil true true
true nil nil true
nil true true true
nil true nil true
nil nil true true
nil nil nil true

:SOLUTION:
using ~flip~ defined in [[*P47 (⋆) Truth tables for logical expressions (2).][P47]], still using backquote expansion to build a giant expression.
#+begin_src lisp :results output
  ;; generate a list of all possible value states,
  ;; each state is a list of (symbol value) pairs
  ;; e. g. ((A T) (B NIL) (C NIL))
  (defun genstates (l)
    (if (null l)
        (list nil)
        (mapcan (lambda (s)
                    (list (cons (cons (car l) '(t)) s)
                          (cons (cons (car l) '(nil)) s)))
                (genstates (cdr l)))))

  ;; generate a closure binded to a state
  (defun genexp (l exp)
    (if (null l)
        (flip exp)
        `(let ((,(caar l) ,(cadar l)))
           ,(genexp (cdr l) exp))))

  (defun table (l exp)
    (mapcar
     (lambda (s)
         (mapcar
          (lambda (x) (format t "~:[nil~:;ture~] " (cadr x))) s)
         (format t "~:[nil~:;ture~]~%" (eval (genexp s exp))))
     (genstates l)))

  ;; test
  (table '(A B C) '((A and (B or C)) equ ((A and B) or (A and C))))
#+end_src

#+RESULTS:
- ture ture ture ture
- nil ture ture ture
- ture nil ture ture
- nil nil ture ture
- ture ture nil ture
- nil ture nil ture
- ture nil nil ture
- nil nil nil ture

:END:
** P49 (⋆⋆) Gray code.
An n-bit Gray code is a sequence of n-bit strings constructed according to certain rules. For example,
n = 1: C(1) = ("0" "1").
n = 2: C(2) = ("00" "01" "11" "10").
n = 3: C(3) = ("000" "001" "011" "010" "110" "111" "101" "100").

Find out the construction rules and write a function with the following specification:

(gray N) returns the N-bit Gray code

Can you apply the method of "result caching" in order to make the function more efficient, when it is to be used repeatedly?

:SOLUTION:
The construction rule is easy, prefix 0 with gray(N-1) and then prefix 1 with reversed gray(N-1)

#+begin_src lisp
  (defun gray (n)
    (if (= 1 n)
        (list (list 0) (list 1))
        (let ((suffix (gray (1- n))))
          (nconc
           (mapcar (lambda (s) (cons 0 s)) suffix)
           (mapcar (lambda (s) (cons 1 s)) (reverse suffix))))))

  ;; test
  (gray 3)
#+end_src

#+RESULTS:
- ((0 0 0) (0 0 1) (0 1 1) (0 1 0) (1 1 0) (1 1 1) (1 0 1) (1 0 0))

As for the cached gray code, we can simply define a variable as cache, when calling ~gray(N)~, firstly try to find N in cache.
If your Lisp implementation don't have hashtable, you can use an associative list or an array instead.
#+begin_src lisp
  (defun gray-cached (n cache)
    (let ((c (gethash n cache)))
      (if c
          c  ;; if found in cache, return the cache directly
          ;; otherwise, calculate it and save it in the cache
          (setf (gethash n cache)
                (if (= 1 n)
                    (list (list 0) (list 1))
                    (let ((suffix (gray-cached (1- n) cache)))
                      (append ;; don't use nconc to avoid destroy cache
                       (mapcar (lambda (s) (cons 0 s)) suffix)
                       (mapcar (lambda (s) (cons 1 s)) (reverse suffix)))))))))

  ;; test
  (let ((cache (make-hash-table :test 'equal)))
    (equal
     (time (gray-cached 10 cache))
     (time (gray-cached 10 cache)))) ;; the second visit should be faster

#+end_src

#+RESULTS:
- T

:END:
** P50 (⋆⋆⋆) Huffman code.
First of all, consult a good book on discrete mathematics or algorithms for a detailed description of Huffman codes!

We suppose a set of symbols with their frequencies, given as a list of (S F) elements. Example: ( (a 45) (b 13) (c 12) (d 16) (e 9) (f 5) ). Our objective is to construct a list of (S C) elements, where C is the Huffman code word for symbol S. In our example, the result could be ( (A "0") (B "101") (C "100") (D "111") (E "1101") (F "1100") ). The task shall be performed by a function huffman defined as follows:

(huffman F) returns the Huffman code table for the frequency table F

:SOLUTION:
SBCL has built-in ~huffman-encode~ and ~huffman-decode~.

One simple method is to build a priority queue, then do binary queue merging to get a tree, the tree itself contain the code map. Here we use ~sort~ for sorting, the implementation of it, ~qsort~, is defined in [[*P28 (⋆⋆) Sorting a list of lists according to length of sublists][P28]].
#+begin_src lisp
  (defun huffman-insert (x b)
    (if (null b)
        (list x)
        (if (< (car x) (caar b))
            (cons x b)
            (cons (car b) (huffman-insert x (cdr b))))))

  (defun huffman-merge (b)
    (let ((x (car b))
          (y (cadr b)))
      (cond
        ((null x) nil) ;; bad case
        ((null y) b)   ;; end
        (t (huffman-merge
            (huffman-insert (list (+ (car x) (car y)) x y)
                            (cddr b)))))))

  (defun huffman-tree (f)
    (car
     (huffman-merge
      (mapcar (lambda (x) (list (cadr x) x))
              (sort f (lambda (p1 p2) (< (cadr p1) (cadr p2))))))))

  (defun huffman-table (tree prefix)
    (let ((left (cadr tree))
          (right (caddr tree)))
      (if (null right) ;; leaf
          (list (list (car left) prefix))
          (nconc
           (huffman-table left (concatenate 'string prefix "0"))
           (huffman-table right (concatenate 'string prefix "1"))))))

  (defun huffman (f)
    (sort (huffman-table (huffman-tree f) "")
          ;; sort the result in symbol name order
          (lambda (l1 l2) (string< (symbol-name (car l1))
                              (symbol-name (car l2))))))


  (huffman '( (a 45) (b 13) (c 12) (d 16) (e 9) (f 5) ))
#+end_src

#+RESULTS:
- ((A "0") (B "101") (C "100") (D "111") (E "1101") (F "1100"))

:END:
* Binary Trees
** Introduction

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p67.gif
[[file:L99.assets/2025-12-06_11-21-12_p67.gif]]

A binary tree is either empty or it is composed of a root element and two successors, which are binary trees themselves.
In Lisp we represent the empty tree by 'nil' and the non-empty tree by the list (X L R), where X denotes the information at the root node and L and R denote the left and right subtrees, respectively. The example tree depicted opposite is therefore represented by the following list:

(a (b (d nil nil) (e nil nil)) (c nil (f (g nil nil) nil)))

Other examples are a binary tree that consists of a root node only:

(a nil nil) or an empty binary tree: nil.

You can check your functions using these example trees. They are given as test cases in [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p54.lisp][p54.lisp]].

** P54A (⋆) Check whether a given expression represents a binary tree
Write a function istree which returns true if and only if its argument is a list representing a binary tree.
Example:
  (istree '(a (b nil nil) nil))
T
  (istree '(a (b nil nil)))
NIL

:SOLUTION:
This is a problem is equal to decide if at each level a list has exactly three members.
#+begin_src lisp
  (defun istree (l)
    (cond ((atom l))                  ;; leaf
          ((= (length l) 3)
           (and (istree (cadr l))     ;; left subtree
                (istree (caddr l))))  ;; right subtree
          (t nil)))

  ;; test
  (list
   (istree '(a (b nil nil) nil))
   (istree '(a (b nil nil)))
   )
#+end_src

#+RESULTS:
- (T NIL)

:END:
** P55 (⋆⋆) Construct completely balanced binary trees
In a completely balanced binary tree, the following property holds for every node: The number of nodes in its left subtree and the number of nodes in its right subtree are almost equal, which means their difference is not greater than one.

Write a function cbal-tree to construct completely balanced binary trees for a given number of nodes. The function should generate all solutions. Put the symbol 'x' as information into all nodes of the tree.
Example:
  (cbal-tree-print 4)
(X (X NIL NIL) (X NIL (X NIL NIL)))
(X (X NIL NIL) (X (X NIL NIL) NIL))
etc......
Note: you can either print the trees or return a list with them all.

  (cbal-tree 4)
((X (X NIL NIL) (X NIL (X NIL NIL))) (X (X NIL NIL) (X (X NIL NIL) NIL)) ......)

:SOLUTION:
According to description, a balanced binary tree can be recursively constructed.
In Common Lisp, ~floor~ and ~ceil~ can also be used for integer division.
#+begin_src lisp :results output
  (defun cbal-tree (n)
    (cond
      ((= 0 n) nil)
      ((= 1 n) (list (list 'X nil nil)))
      ((= 2 n) (list (list 'X '(X nil nil) nil)
                     (list 'X nil '(X nil nil))))
      (t (let* ((st1 (floor (1- n) 2))
                (st2 (- (1- n) st1)))
           (mapcan
            (lambda (t1)
              (mapcan
               (lambda (t2)
                 (if (= st1 st2)
                     (list (list 'X t1 t2))
                     (list (list 'X t1 t2) (list 'X t2 t1))))
               (cbal-tree st2)))
            (cbal-tree st1))))))

  (defun cbal-tree-print (n)
    (mapc (lambda (x) (format t "~S~%" x)) (cbal-tree n)))

  (cbal-tree-print 4)
#+end_src

#+RESULTS:
- (X (X NIL NIL) (X (X NIL NIL) NIL))
- (X (X (X NIL NIL) NIL) (X NIL NIL))
- (X (X NIL NIL) (X NIL (X NIL NIL)))
- (X (X NIL (X NIL NIL)) (X NIL NIL))

:END:
** P56 (⋆⋆) Symmetric binary trees
Let us call a binary tree symmetric if you can draw a vertical line through the root node and then the right subtree is the mirror image of the left subtree. Write a function symmetric to check whether a given binary tree is symmetric. We are only interested in the structure, not in the contents of the nodes.

:SOLUTION:
Use ~xor~ and ~nor~ defined in [[*P46 (⋆⋆) Truth tables for logical expressions.][P46]]
#+begin_src lisp
  (defun symmetric-aux (t1 t2)
    (cond
      ((xor t1 t2) nil)                           ;; one is nil, one is non-nil
      ((nor t1 t2) t)                             ;; both nil
      ((and (atom t1) (atom t2)) t)               ;; both atom
      ((or (atom t1) (atom t2)) nil)              ;; one list, one atom
      (t (and (symmetric-aux (cadr t1) (caddr t2))  ;; both list
              (symmetric-aux (caddr t1) (cadr t2))))))

  (defun symmetric (tree)
    (symmetric-aux (cadr tree) (caddr tree)))

  ;; test
  (list
   (symmetric
    '(X (X NIL (X NIL NIL)) (X (X NIL NIL) NIL)))
   (symmetric
    '(X (X NIL (X NIL NIL)) (X NIL (X NIL NIL))))
   )
#+end_src

#+RESULTS:
- (T NIL)

:END:
** P57 (⋆⋆) Binary search trees (dictionaries)
Write a function to construct a binary search tree from a list of integer numbers.
Example:
  (construct '(3 2 5 7 1))
(3 (2 (1 nil nil) nil) (5 nil (7 nil nil)))

Then use this function to test the solution of the problem P56.
Example:
  (symmetric '(5 3 18 1 4 12 21))
T
  (symmetric '(3 2 5 7 1))
T
  (symmetric '(3 2 5 7))
NIL

:SOLUTION:
For list destructive operations, we use ~rplacd~ here.
#+begin_src lisp
  (defun bt-insert (root x)
    (if (< x (car root))
        (if (null (cadr root))
            (rplacd root (cons (list x nil nil) (cddr root)))
            (bt-insert (cadr root) x))
        (if (null (caddr root))
            (rplacd (cdr root) (list (list x nil nil)))
            (bt-insert (caddr root) x))))

  (defun construct (l)
    (let ((root (list (car l) nil nil)))
      (mapc (lambda (x) (bt-insert root x)) (cdr l))
      root))

  ;;test
  (list
   (symmetric (construct '(5 3 18 1 4 12 21)))
   (symmetric (construct '(3 2 5 7 1)))
   (symmetric (construct '(3 2 5 7))))

#+end_src

#+RESULTS:
- (T T NIL)

:END:
** P58 (⋆⋆) Generate-and-test paradigm
Apply the generate-and-test paradigm to construct all symmetric, completely balanced binary trees with a given number of nodes. Example:
  (sym-cbal-trees-print 5)
(X (X NIL (X NIL NIL)) (X (X NIL NIL) NIL))
(X (X (X NIL NIL) NIL) (X NIL (X NIL NIL)))
...

How many such trees are there with 57 nodes? Investigate about how many solutions there are for a given number of nodes. What if the number is even? Write an appropriate function.

:SOLUTION:
#+begin_src lisp :results output
  (defun sym-cbal-trees-print (n)
    (mapc (lambda (x) (format t "~S~%" x))
          (mapcan (lambda (tree) (when (symmetric tree) (list tree)))
                  (cbal-tree n))))

  (sym-cbal-trees-print 5)
#+end_src

#+RESULTS:
- (X (X (X NIL NIL) NIL) (X NIL (X NIL NIL)))
- (X (X NIL (X NIL NIL)) (X (X NIL NIL) NIL))

:END:
** P59 (⋆⋆) Construct height-balanced binary trees
In a height-balanced binary tree, the following property holds for every node: The height of its left subtree and the height of its right subtree are almost equal, which means their difference is not greater than one.

Write a function hbal-tree to construct height-balanced binary trees for a given height. The function should generate all solutions. Put the letter 'x' as information into all nodes of the tree.
Example:
  (hbal-tree 3)
(X (X (X NIL NIL) (X NIL NIL)) (X (X NIL NIL) (X NIL NIL)))
= (X (X (X NIL NIL) (X NIL NIL)) (X (X NIL NIL) NIL))
etc......

:SOLUTION:
Note that depth(T) = max(depth(left), depth(right)), and according to definition of balanced tree, depth(left) - depth(right) in {-1, 0, 1}.
#+begin_src lisp :results output
  (defun hbal-tree (n)
    (cond
      ((= n 0) nil)
      ((= n 1) (list (list 'X nil nil)))
      ((= n 2) (list (list 'X (list 'X nil nil) (list 'X nil nil))
                     (list 'X (list 'X nil nil) nil)
                     (list 'X nil (list 'X nil nil))))
      (t
       (let ((s1 (hbal-tree (- n 1)))
             (s2 (hbal-tree (- n 2))))
         (append
          ;; depth(s1) - depth(s2) = 0
          (mapcan
           (lambda (left)
             (mapcan
              (lambda (right) (list (list 'X left right)))
              s1))
           s1)
          ;; depth(s1) - depth(s2) = -1 or 1
          (mapcan
           (lambda (left)
             (mapcan
              (lambda (right)
                (list (list 'X left right)
                      (list 'X right left)))
              s2))
           s1))))))

  ;; test
  (mapc #'print (hbal-tree 3))
#+end_src

#+RESULTS:
- (X (X (X NIL NIL) (X NIL NIL)) (X (X NIL NIL) (X NIL NIL)))
- (X (X (X NIL NIL) (X NIL NIL)) (X (X NIL NIL) NIL))
- (X (X (X NIL NIL) (X NIL NIL)) (X NIL (X NIL NIL)))
- (X (X (X NIL NIL) NIL) (X (X NIL NIL) (X NIL NIL)))
- (X (X (X NIL NIL) NIL) (X (X NIL NIL) NIL))
- (X (X (X NIL NIL) NIL) (X NIL (X NIL NIL)))
- (X (X NIL (X NIL NIL)) (X (X NIL NIL) (X NIL NIL)))
- (X (X NIL (X NIL NIL)) (X (X NIL NIL) NIL))
- (X (X NIL (X NIL NIL)) (X NIL (X NIL NIL)))
- (X (X (X NIL NIL) (X NIL NIL)) (X NIL NIL))
- (X (X NIL NIL) (X (X NIL NIL) (X NIL NIL)))
- (X (X (X NIL NIL) NIL) (X NIL NIL))
- (X (X NIL NIL) (X (X NIL NIL) NIL))
- (X (X NIL (X NIL NIL)) (X NIL NIL))
- (X (X NIL NIL) (X NIL (X NIL NIL)))

:END:
** P60 (⋆⋆) Construct height-balanced binary trees with a given number of nodes
Consider a height-balanced binary tree of height H. What is the maximum number of nodes it can contain?
Clearly, MAXN = 2**H - 1. However, what is the minimum number MINN? This question is more difficult. Try to find a recursive statement and turn it into a function minnodes defined as follows:

(min-nodes H) returns the minimum number of nodes in a height-balanced binary tree of height H.


On the other hand, we might ask: what is the maximum height H a height-balanced binary tree with N nodes can have?

(max-height N) returns the maximum height of a height-balanced binary tree with N nodes


Now, we can attack the main problem: construct all the height-balanced binary trees with a given number of nodes.

(hbal-tree-nodes N) returns all height-balanced binary trees with N nodes.

Find out how many height-balanced trees exist for N = 15.

:SOLUTION:
Easy to count:
s(n) = s(n-2) s(n-1) + s(n-1) s(n-2) + s(n-1) s(n-1) = (2 s(n-2) + s(n-1) ) s(n-1)
To calculate s(15) a recursive function is too slow, because it has two subtrees to recurse, we should use an iteration function.
SBCL supports arbitrary precision arithmetics, if your implementation can't, you may need to find a large integer computation library, or do it on yourselves, use a long vector to represent a large number, then use DFT for multiplication optimization.
#+begin_src lisp
  (defun hbal-tree-nodes-iter (i n s1 s2)
    (if (< i n)
       (hbal-tree-nodes-iter
        (1+ i) n (* (+ s1 s2 s2) s1) s1)
       s1))

  (defun hbal-tree-nodes (n)
    (cond
      ((= n 1) 1)
      ((= n 2) 3)
      (t (hbal-tree-nodes-iter 2 n 3 1))))

  ;; reset
    (hbal-tree-nodes 15)
#+end_src

#+RESULTS:
- 19235750625957776631605001614576603301543852854874135383044937949109520998025229614925070005113186971971893353314648684886363213150865573859545392611152416342609308720685863711017007985623507695649492901436855076641854339456907684274358791448362419442581885228452656096970908789866273920366387649790830003010299338603887863150466677531394911018706256109033785218420485782571902205756625527352917475783595429209229810719668133448149194240546522011067616537045473008874573271357324725161426255274083714313267828567346483618103773658048707010915093392668768043164056319241552188390961032507075765181018792759558839254952228588579337362265751580326942214030375323221445891793755038771355325396502089468968474597237812739041997171544277027956779951225962324716031382225317557716176600515363142688949012259002741522739421851237068430860004011022808511838284444322888080972986428040771153463200449778836372504545804948863611564168453715138440709469066391144520740039825406534516171332786137308651872695898329633095771164214645201566558681533550703936149706524408735567431168655401452902014867828744710748286089028694893876460796761486024181835654893803480139251978847586088924687566666784622787863741936362636808704564160533964837975621413527355504553823807141151968465299605662765817648084024355069205751386591333465717950605079594615926909670758096902132627499954531278286624833949200382893514169811194141670238624151730243474765875169510431596223068609090182173710338275320235799118116833751796196479038026862089243960092540075719519414272039141273194041162952128286814935496896194465865095557040962559659967412300792146008128732640494432052962294327955476447426823389516259869969687504476731731850634869722334665776050569920018659565557460036204782806982273960131123086629153062446996544006508398891582287673648117019662376253550214586955474512777681826005824445931596179246838697452028719833049059324781196180418293261832125965212229080753650912800505739325472060443381204449156143650388067443456448049433378866396102033942345394909767896056653429928165289264257397772553793987155243061870866346106646637628438116883279373388201880006442992938812657285520990003508964710625038884630694256011556288597836323777282604818077512044603828059620842611287101429699214107088335634999434681993127247132547652137212493459113218373921379113076666703027372910677757984126251035796095413917513831588980267427106613579805056615890326064924826894334909406323368898622235162412747840204281807856483703622784804205647185714900583501334245237663534519508268424196411504979295454642480956898035898806426349416809408393682762853453956192043883711803225935498720470030586112771790069081649970177780621222115534484145531979473306197026435688161016469142760862735425411657089059212560117584763921798102284138809622284600141610820647635802529425533601145360765856432568517569088969614121927578345477234649626123439247660648697675767391867543334321115661694421862746524314593199842265465699997080725911720571767076289499353032351117106892964365279053972401104397600766880991877144673947762447870516790136218738306909391815582623466629797039090891333642140923270662096310302132012576239293740278181492962693299091743421765357028513887778941701039194068005049718565731307565207243809266871189801626713380137387053991724292090850252623668645799983248496537726961047387317624206298500825821769265747083904393472729579275586276756227189150854276855390615342753058047569714376675795358939845602869278211856006066312375083111829296201180372170173808316751004630479954519297344530141890896086674704999381969473661454957882716833709568204759683710360235176913333184284557054397903526171914454537806037291301817072325470192649459534732101610668888757859658293200374311384567185519994486540774024797899829317108562987536032683615976009781398140211801917917207572351789646571119932332783951990391707563595950969736402732809026410534579729963039620439602096165902047696983923129458363251525806289428649133331895641399537565114214101785390841071711462867700456006865961057836151546450806236677882999792364128774248664861518584807227714724872582012070248670462821967306249711186794527334200816846802164955440513656218177189981690316945408737156963536801899058245232088088647001104667550062524302672214948424987450231362608916167689346536561217067688162925148457334136576157958431175361631324465777913006354956154260234749648066396636502291152079683824746004593579370260651077893391364806514069703183481671369790346103420115919739174564737487596824351030221034993313317326894285679984483122301551166029799038319715501218209201170907853687186177645974188858858052608074876139751003403725330253945844228835116231894522954376300501633073796868330174353555371011853956127814757011637632327763890216841517147414458284999521345608032809772125661930372620621588430989124086088728347470364721820634421063405907507363496322187545791564085590093029455061470571357577096367683676653320931633848303784625188221886687886016168374605471721321858276987706015513449971705842618190101802248323744667599968352904523077892122046253415275002772945587648014846052730311592384541681359511056115252358722500503063201904296875

:END:
** P61 (⋆) Count the leaves of a binary tree
A leaf is a node with no successors. Write a function count-leaves to count them.

(count-leaves tree) returns the number of leaves of binary tree tree

:SOLUTION:
Simply do tree travel, DFS or BFS with record, here we use BFS..
Use ~nor~ defined in [[*P46 (⋆⋆) Truth tables for logical expressions.][P46]]
#+begin_src lisp
  (defun count-leaves (root)
    (cond
      ((null root) 0)
      ((nor (cadr root) (caddr root)) 1)
      (t (+ (count-leaves (cadr root))
            (count-leaves (caddr root))))))

  ;; test
  (count-leaves '(X (X (X NIL NIL) NIL) (X (X NIL NIL) (X NIL NIL))))
#+end_src

#+RESULTS:
- 3

:END:
** P61A (⋆) Collect the leaves of a binary tree in a list
A leaf is a node with no successors. Write a function leaves to return them in a list.

(leaves tree) returns the list of all leaves of the binary tree tree

:SOLUTION:
Use ~nor~ defined in [[*P46 (⋆⋆) Truth tables for logical expressions.][P46]]
#+begin_src lisp
  (defun leaves (root)
    (cond
      ((null root) nil)
      ((nor (cadr root) (caddr root)) (list root))
      (t (append (leaves (cadr root))
                 (leaves (caddr root))))))

  ;; test
  (leaves '(A (B (C NIL NIL) NIL) (D (E NIL NIL) (F NIL NIL))))
#+end_src

#+RESULTS:
- ((C NIL NIL) (E NIL NIL) (F NIL NIL))

:END:
** P62 (⋆) Collect the internal nodes of a binary tree in a list
An internal node of a binary tree has either one or two non-empty successors. Write a function internals to collect them in a list.

(internals tree) returns the list of internal nodes of the binary tree tree.

:SOLUTION:
Use ~nor~ defined in [[*P46 (⋆⋆) Truth tables for logical expressions.][P46]], it is the inverse of P61A.
#+begin_src lisp
  (defun internals (root)
    (cond
      ((null root) nil)
      ((nor (cadr root) (caddr root)) nil)
      (t (append
          (list root)
          (internals (cadr root))
          (internals (caddr root))))))

  ;; test
  (internals '(A (B (C NIL NIL) NIL) (D (E NIL NIL) (F NIL NIL))))
#+end_src

#+RESULTS:
- ((A (B (C NIL NIL) NIL) (D (E NIL NIL) (F NIL NIL))) (B (C NIL NIL) NIL)
- (D (E NIL NIL) (F NIL NIL)))

:END:
** P62B (⋆) Collect the nodes at a given level in a list
A node of a binary tree is at level N if the path from the root to the node has length N-1. The root node is at level 1. Write a function atlevel to collect all nodes at a given level in a list.

(atlevel tree L) returns the list of nodes of the binary tree tree at level L

Using atlevel it is easy to construct a function levelorder which creates the level-order sequence of the nodes. However, there are more efficient ways to do that.

:SOLUTION:
#+begin_src lisp
  (defun atlevel-aux (root level n)
    (cond
      ((null root) nil)
      ((= n level) (list root))
      ((< n level)
       (append
        (atlevel-aux (cadr root) level (1+ n))
        (atlevel-aux (caddr root) level (1+ n))))))

  (defun atlevel (root level)
    (atlevel-aux root level 1))

  ;; test
  (atlevel '(A (B (C NIL NIL) NIL) (D (E NIL NIL) (F NIL NIL))) 2)
#+end_src

#+RESULTS:
- ((B (C NIL NIL) NIL) (D (E NIL NIL) (F NIL NIL)))

:END:
** P63 (⋆⋆) Construct a complete binary tree
A complete binary tree with height H is defined as follows: The levels 1,2,3,...,H-1 contain the maximum number of nodes (i.e 2**(i-1) at the level i, note that we start counting the levels from 1 at the root). In level H, which may contain less than the maximum possible number of nodes, all the nodes are "left-adjusted". This means that in a levelorder tree traversal all internal nodes come first, the leaves come second, and empty successors (the nil's which are not really nodes!) come last.

Particularly, complete binary trees are used as data structures (or addressing schemes) for heaps.

We can assign an address number to each node in a complete binary tree by enumerating the nodes in levelorder, starting at the root with number 1. In doing so, we realize that for every node X with address A the following property holds: The address of X's left and right successors are 2*A and 2*A+1, respectively, supposed the successors do exist. This fact can be used to elegantly construct a complete binary tree structure. Write a function complete-binary-tree with the following specification:

(complete-binary-tree N) returns a complete binary tree with N nodes

Test your function in an appropriate way.

:SOLUTION:
Here we use a bottom-up strategy, first we enumerate all possible sequences of the lowerest level, then build whole tree on it.
Use ~repeat~ from [[*P12 (⋆⋆) Decode a run-length encoded list.][P12]] and ~range~ from [[*P22 (⋆) Create a list containing all integers within a given range.][P22]].
To test the function, we use ~atlevel~ defined in [[*P62B (⋆) Collect the nodes at a given level in a list][P62B]], the last level should be an incremental sequence of (X NIL NIL).
#+begin_src lisp :results output
  (defun build-up-forest (l)
    (cons (list 'X (car l) (cadr l))
          (when (cddr l) (build-up-forest (cddr l)))))

  (defun build-cbt (l)
    (cond
      ((null (cdr l)) (car l))
      (t (build-cbt (build-up-forest l)))))

  (defun complete-binary-tree (n)
    (mapcar
     #'build-cbt
     (mapcar (lambda (x)
               (nconc (repeat x (list 'X nil nil))
                      (repeat (- (expt 2 (1- n)) x) nil)))
             (range 1 (expt 2 (1- n))))))

  ;; test
  (let ((n 4))
    (mapc (lambda (tree) (print (atlevel tree 4)))
          (complete-binary-tree 4)))
#+end_src

#+RESULTS:
- ((X NIL NIL))
- ((X NIL NIL) (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL)
- (X NIL NIL))
- ((X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL) (X NIL NIL)
- (X NIL NIL) (X NIL NIL))

:END:
** P64 (⋆⋆) Layout a binary tree (1)
Consider a binary tree as the usual symbolic expression (X L R) or nil. As a preparation for drawing the tree, a layout algorithm is required to determine the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is shown in the illustration below.


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p64.gif
[[file:L99.assets/2025-12-06_11-22-29_p64.gif]]


In this layout strategy, the position of a node v is obtained by the following two rules:

x(v) is equal to the position of the node v in the inorder sequence
y(v) is equal to the depth of the node v in the tree


In order to store the position of the nodes, we extend the symbolic expression representing a node (and its successors) as follows:

nil represents the empty tree (as usual)
(W X Y L R) represents a (non-empty) binary tree with root W "positioned" at (X,Y), and subtrees L and R

Write a function layout-binary-tree with the following specification:

(layout-binary-tree tree) returns the "positioned" binary tree obtained from the binary tree tree

Test your function in an appropriate way.

:SOLUTION:
To test the layout function, we write a layout print function ~print-bt-layout~, which creates an svg image.
#+begin_src lisp
  ;; print functions
  (defun print-bt-node (out s x y &aux (w 25))
    (format out "<circle cx=\"~a\" cy=\"~a\" r=\"~a\" stroke=\"black\" fill=\"white\" />~%"
            (* x w) (* y w) 15)
    (format out "<text x=\"~a\" y=\"~a\" text-anchor=\"middle\" dominant-baseline=\"central\" font-size=\"12\" fill=\"black\">~a</text>~%"
            (* x w) (* y w) (symbol-name s)))

  (defun print-bt-line (out x1 y1 x2 y2 &aux (w 25))
    (format out "<line x1=\"~a\" y1=\"~a\" x2=\"~a\" y2=\"~a\" stroke=\"black\" />~%"
            (* x1 w) (* y1 w) (* x2 w) (* y2 w)))

  (defun print-grid (out cols rows)
    (dotimes (i rows) (print-bt-line out 0 i cols i))
    (dotimes (i cols) (print-bt-line out i 0 i rows)))

  (defun print-bt-layout-aux (out layout)
    (let* ((subtrees (cdddr layout))
           (l (car subtrees))
           (r (cadr subtrees)))
      (when l
        (print-bt-line out (cadr layout) (caddr layout) (cadr l) (caddr l))
        (print-bt-layout-aux out l))
      (when r
        (print-bt-line out (cadr layout) (caddr layout) (cadr r) (caddr r))
        (print-bt-layout-aux out r))
      (print-bt-node out (car layout) (cadr layout) (caddr layout))))

  (defun print-bt-layout (cols rows layout)
    (let ((out t))
      (format out "<svg xmlns=\"http://www.w3.org/2000/svg\">~%")
      (format out "<rect width=\"100%\" height=\"100%\" fill=\"white\" />~%")
      (print-grid out cols rows)
      (when layout (print-bt-layout-aux out layout))
      (format out "</svg>")))
#+end_src

#+RESULTS:
- PRINT-BT-LAYOUT

Now let's write the layout function:
#+begin_src lisp :results output file :file P64-solution.svg :output-dir L99.assets/
  (defun layout-binary-tree-aux (tree rpos depth)
    (if (null tree)
        (cons 0 nil) ;; return '(size . layout-tree)
        (let* ((l (layout-binary-tree-aux (cadr tree) rpos (1+ depth)))
               (r (layout-binary-tree-aux (caddr tree) (+ rpos (car l) 1) (1+ depth))))
          (cons (+ (car l) 1 (car r))
                (list (car tree) (+ rpos (car l) 1) depth (cdr l) (cdr r)))
          )))

  (defun layout-binary-tree (tree)
    (cdr (layout-binary-tree-aux tree 0 1)))

  ;; test
  (print-bt-layout
   13 7
   (layout-binary-tree
    '(n
      (k
       (c (a nil nil)
        (h (g (e nil nil) nil) nil))
       (m nil nil))
      (u (p nil
          (s (q nil nil) nil))
       nil))))
#+end_src

#+RESULTS:
[[file:L99.assets/P64-solution.svg]]

Press ~C-c C-x C-v~, you can preview images in org-mode.

:END:
** P65 (⋆⋆) Layout a binary tree (2)
An alternative layout method is depicted in the illustration opposite. Find out the rules and write the corresponding Lisp function. Hint: On a given level, the horizontal distance between neighboring nodes is constant.

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p65.gif
[[file:L99.assets/2025-12-06_11-23-44_p65.gif]]


Use the same conventions as in problem P64 and test your function in an appropriate way.

:SOLUTION:
In this problem, note that between each two levels, the interval widths are equal, so it is determined by depth.
We will first search the tree top down without fill x(v) but only save y(v), then again fill x(v) top down with y(v).
#+begin_src lisp :results output file :file P65-solution.svg :output-dir L99.assets/
  (defun layout-binary-tree-1-depth (tree depth)
    (if (null tree)
        depth
        (max (layout-binary-tree-1-depth (cadr tree) (1+ depth))
             (layout-binary-tree-1-depth (caddr tree) (1+ depth)))))

  (defun layout-binary-tree-1-fill (tree rpos i depth)
    (when tree
      (let* ((l (layout-binary-tree-1-fill
                 (cadr tree) rpos (1- i) (1+ depth)))
             (r (layout-binary-tree-1-fill
                 (caddr tree) (+ rpos (expt 2 (1- i))) (1- i) (1+ depth))))
        (list (car tree) (+ rpos (expt 2 (1- i))) depth l r))))

  (defun layout-binary-tree-1 (tree)
    (let ((d (layout-binary-tree-1-depth tree 0)))
      (layout-binary-tree-1-fill tree -1 d 1)))

  ;; test
  (print-bt-layout
   24 6
   (layout-binary-tree-1
    '(n
      (k
       (c (a nil nil)
        (e (d nil nil) (g nil nil)))
       (m nil nil))
      (u (p nil
          (q nil nil))
       nil))))
#+end_src

#+RESULTS:
[[file:L99.assets/P65-solution.svg]]

:END:
** P66 (⋆⋆⋆) Layout a binary tree (3)
Yet another layout strategy is shown in the illustration opposite. The method yields a very compact layout while maintaining a certain symmetry in every node. Find out the rules and write the corresponding Lisp function. Hint: Consider the horizontal distance between a node and its successor nodes. How tight can you pack together two subtrees to construct the combined binary tree?


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p66.gif
[[file:L99.assets/2025-12-06_11-25-52_p66.gif]]


Use the same conventions as in problem P64 and P65 and test your function in an appropriate way. Note: This is a difficult problem. Don't give up too early!

Which layout do you like most?

:SOLUTION:
This problem is not very clear about the rules, as for my understanding, we should keep:

1. Left child and right child have the same relative displacement value to root.
2. Make that displacement value as small as possible for each root.

This problem has some spicy corner cases, for example: (A is root, the tree is drawn from left to right.)
#+begin_src ascii
        G
       / \
      D   I
     /     \
    C   E   K
   /   / \   \
  A   F   G   M
   \ /     \   \
    B   H   L   O
     \ / \   \   \
      Q   R   N   P
#+end_src

If we don't know the shape of the whole subtree, we can't decide whether it is compact enough at the root level. For example, in the diagram above, to compact subtrees B and C, if we only compute margin of B and C at level 2:

r_margin(B) = 1
l_margin(C) = 2

But actually, 1 is determined by E while 2 is determined by P, they're not at the same level.

So, to arrange the nodes as compact as possible, we must detect it level by level.

r_margin(B) = (-1 0 1 0 -1 -2)
l_margin(C) = (-1 -2 -3 -2 -1 0 1 2)

Then we found actually the maximal margin needs to reserve is -2, which means we don't need to leave any margin.

With these we can get the correct displacement. And suppose one displacement is made, we will need to recompute the whole subtrees. So it will be simpler to only keep relative displacements, and compute the absolute coordinates after the tree is completely placed.

#+begin_src lisp :results output file :file P66-solution.svg :output-dir L99.assets/
  (defun layout-binary-tree-2-margin (tree dir)
    (when tree
      (let ((lm (layout-binary-tree-2-margin (cadr tree) dir))
            (rm (layout-binary-tree-2-margin (caddr tree) dir)))
        (let ((len (max (length lm) (length rm)))
              (pm (cond ((equal dir 'L) lm) ((equal dir 'R) rm)))   ;; primary margin
              (sm (cond ((equal dir 'L) rm) ((equal dir 'R) lm))))  ;; secondary margin
        (cons -1
              (loop for i from 0 below len
                    for p = (nth i pm) for s = (nth i sm)
                    collect (if p (1+ p) (1- s))))))))

  (defun layout-binary-tree-2-aux (tree rpos depth)
    (cond
      ((null tree) nil)
      (t
       (let* ((l_rmargin (layout-binary-tree-2-margin (cadr tree) 'R))
              (r_lmargin (layout-binary-tree-2-margin (caddr tree) 'L))
              (len (max (length l_rmargin) (length r_lmargin)))
              (wl (mapcar (lambda (a b) (+ a b)) l_rmargin r_lmargin))
              (width (if wl (apply #'max wl) -1))
              (d (max (ceiling (+ width 3) 2) 1)))
         (list (car tree) rpos depth
               (layout-binary-tree-2-aux (cadr tree) (- rpos d) (1+ depth))
               (layout-binary-tree-2-aux (caddr tree) (+ rpos d) (1+ depth)))))))

  (defun layout-binary-tree-calc-rpos (tree)
    (when tree
      (let ((children (cdddr tree)))
        (max
         (abs
          (if (car children)
              (layout-binary-tree-calc-rpos (car children))
              (cadr tree)))
         (abs
          (if (cadr children)
              (layout-binary-tree-calc-rpos (cadr children))
              (cadr tree)))))))

  (defun layout-binary-tree-disp (tree dx dy)
    (when tree
      (let ((children (cdddr tree)))
        (layout-binary-tree-disp (car children) dx dy)
        (layout-binary-tree-disp (cadr children) dx dy)
        (rplacd tree
                (cons (+ (cadr tree) dx)
                      (cons (+ (caddr tree) dy)
                            children))))
      tree))

  (defun layout-binary-tree-2 (tree)
    (let ((layout (layout-binary-tree-2-aux tree 0 1)))
      (layout-binary-tree-disp
       layout (1+ (layout-binary-tree-calc-rpos layout)) 0)))

  ;; test
  (print-bt-layout
   8 6
   (layout-binary-tree-2
    '(n
      (k
       (c (a nil nil)
        (e (d nil nil) (g nil nil)))
       (m nil nil))
      (u (p nil
          (q nil nil))
       nil))))
#+end_src

#+RESULTS:
[[file:L99.assets/P66-solution.svg]]

Maybe I prefer P64, because that tree is concise as well as compact.

:END:
** P67 (⋆⋆) A string representation of binary trees
#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p67.gif
[[file:L99.assets/2025-12-06_11-27-00_p67.gif]]


Somebody represents binary trees as strings of the following type (see example opposite):

a(b(d,e),c(,f(g,)))

a) Write a Lisp function which generates this string representation, if the tree is given as usual (as nil or (X L R) expression). Then write a function which does this inverse; i.e. given the string representation, construct the tree in the usual form.

:SOLUTION:
a) The encoder is simple, just format it in prefix order .
#+begin_src lisp
  (defun binary-tree-string-encode (tree)
    (when tree
      (concatenate
       'string
       (symbol-name (car tree))
       (when (or (cadr tree) (caddr tree))
         (concatenate 'string
                      "(" (binary-tree-string-encode (cadr tree))
                      "," (binary-tree-string-encode (caddr tree))
                      ")")))))

  (binary-tree-string-encode
   '(a (b (d nil nil) (e nil nil)) (c nil (f (g nil nil) nil))))
#+end_src

#+RESULTS:
- A(B(D,E),C(,F(G,)))

b) This is a little bit difficult, because we have to craft a lexer to tokenize the string. But there is no such a facility in Common Lisp's standard library. So we have to do it on ourselves. This tokenizer is simple, which only tokenizing symbols by deliminaters. Here we assume that there are no strange symbols like ~|A(|~, which may cause ambiguity.

As for the parser part, this grammar can be reduced to a linear grammar, which ensures that there is at most one non-terminal at right side at each production. So the parser function can be made free from any context except for its previous and next production.

#+begin_src lisp
  (defun binary-tree-string-tokenize (s)
    (let ((token-queue)
          (char-list))
      (flet ((pop-token-and-push (x)
               (unless (null char-list)
                 (push (cons 'SYM (intern (coerce (nreverse char-list) 'string)))
                       token-queue)
                 (setf char-list nil))
               (push x token-queue)))
        (loop
          for c across s
          do (cond
               ((char= c #\() (pop-token-and-push (cons 'LP c)))
               ((char= c #\,) (pop-token-and-push (cons 'CO c)))
               ((char= c #\)) (pop-token-and-push (cons 'RP c)))
               (t (push c char-list)))))
      ;; To increase performance we make use a ring buffer rather than list.
      ;; CommonLisp doesn't provide such a structure as built-in.
      (nreverse token-queue)))

  ;; state machine:
  ;;
  ;;                               +-----------+------+
  ;;                               |           |      |
  ;;                               v           v      |
  ;; ROOT -sym-> RDLP -+-(-> LCLD -+-,-> RCLD -+-)-> ROOT
  ;;                   ^      |    |      |    ^
  ;;                   |     sym   |     sym   |
  ;;                   |      |    |      |    |
  ;;                   |      v    |      v    |
  ;;                   +--- RDCO ->+    RDRP ->+
  ;;                   ^                  |
  ;;                   |                  |
  ;;                   +------------------+

  (defun binary-tree-decode (l stack state)
    ;; debug print
    ;; (format t "~a~%~a ~a~%" stack state (car l))
    (cond
      ((null l)
       (t (error "Unterminated sequence; state = ~a" state)))
      ((and (null (cdr l)) (equal (caar l) 'RP))
       (car stack)) ;; out here
      ((equal state 'ROOT)
       (cond
         ((equal (caar l) 'CO)
          (binary-tree-decode (cdr l) stack 'RCLD))
         ((equal (caar l) 'RP)
          (binary-tree-decode (cdr l) (cdr stack) 'ROOT))
         ((equal (caar l) 'SYM)
          (binary-tree-decode
           (cdr l) (cons (list (cdar l) nil nil) stack) 'RDLP))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      ((equal state 'LCLD)
       (cond
         ((equal (caar l) 'CO)
          (binary-tree-decode (cdr l) stack 'RCLD))
         ((equal (caar l) 'SYM)
          (rplacd (car stack) (cons (list (cdar l) nil nil)
                                    (cddar stack)))
          (binary-tree-decode (cdr l) stack 'RDCO))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      ((equal state 'RCLD)
       (cond
         ((equal (caar l) 'RP)
          (binary-tree-decode (cdr l) (cdr stack) 'ROOT))
         ((equal (caar l) 'SYM)
          (rplacd (car stack) (list (cadar stack)
                                    (list (cdar l) nil nil)))
          (binary-tree-decode (cdr l) stack 'RDRP))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      ((equal state 'RDLP)
       (cond
         ((equal (caar l) 'LP)
          (binary-tree-decode (cdr l) stack 'LCLD))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      ((equal state 'RDCO)
       (cond
         ((equal (caar l) 'CO)
          (binary-tree-decode (cdr l) stack 'RCLD))
         ((equal (caar l) 'LP)
          (binary-tree-decode
           (cdr l) (cons (cadr (car stack)) stack) 'LCLD))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      ((equal state 'RDRP)
       (cond
         ((equal (caar l) 'LP)
          (binary-tree-decode
           (cdr l) (cons (caddr (car stack)) stack) 'LCLD))
         ((equal (caar l) 'RP)
          (binary-tree-decode (cdr l) (cdr stack) 'ROOT))
         (t (error "Syntax error at ~a; state = ~a" l state))))
      (t (error "Unknown symbol at ~a" l))))

  (defun binary-tree-string-decode (s)
    (binary-tree-decode (binary-tree-string-tokenize s) '() 'ROOT))

  (binary-tree-string-decode "A(B(D,E),C(,F(G,)))")
#+end_src

#+RESULTS:
- (A (B (D NIL NIL) (E NIL NIL)) (C NIL (F (G NIL NIL) NIL)))

:END:
** P68 (⋆⋆) Preorder and inorder sequences of binary trees
We consider binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67.

a) Write functions preorder and inorder that construct the preorder and inorder sequence of a given binary tree, respectively. The results should be lists, e.g. (A B D E C F G) for the preorder sequence of the example in problem P67.

b) Can you write the inverse of preorder from problem part a) ; i.e. given a preorder sequence, construct a corresponding tree?

c) If both the preorder sequence and the inorder sequence of the nodes of a binary tree are given, then the tree is determined unambiguously. Write a function pre-in-tree that does the job.

:SOLUTION:
a) easy
#+begin_src lisp
  (defun preorder-sequence (tree)
    (when tree
      (cons (car tree)
            (nconc
             (preorder-sequence (cadr tree))
             (preorder-sequence (caddr tree))))))

  (preorder-sequence
   '(a (b (d nil nil) (e nil nil)) (c nil (f (g nil nil) nil))))
#+end_src

#+RESULTS:
- (A B D E C F G)

#+begin_src lisp
  (defun inorder-sequence (tree)
    (when tree
      (nconc
       (inorder-sequence (cadr tree))
       (cons (car tree)
             (inorder-sequence (caddr tree))))))

  (inorder-sequence
   '(a (b (d nil nil) (e nil nil)) (c nil (f (g nil nil) nil))))
#+end_src

#+RESULTS:
- (D B E A C G F)

b) no, obviously, a sequence of nodes usually can't determine a tree uniquely.

c) yes, with preorder we get order of levels, with inorder we get order in a level, with both we can know position of a node. However, there is a restriction that, no duplicate nodes in the tree. Suppose there is a sequence (A A) for both preoder and inorder, it is still ambiguious.

#+begin_src lisp
  (defun split-at-aux (l r x)
    (if (or (null r)
            (equal (car r) x))
        (list (reverse l) (cdr r))
        (split-at-aux (cons (car r) l) (cdr r) x)))

  (defun split-at (l x)
    (split-at-aux nil l x))

  (defun slice-filter (l r)
    (cond
      ((null l) nil)
      ((member (car l) r) l)
      (t (slice-filter (cdr l) r))))

  (defun pre-in-tree (pre in)
    (when in
      (let ((l (slice-filter pre in)))
        (when l
          (let ((children (split-at in (car l))))
            (list
             (car l) ;; root
             (pre-in-tree l (car children))
             (pre-in-tree l (cadr children))))))))

  (pre-in-tree '(A B D E C F G) '(D B E A C G F))
#+end_src

#+RESULTS:
- (A (B (D NIL NIL) (E NIL NIL)) (C NIL (F (G NIL NIL) NIL)))

:END:
** P69 (⋆⋆) Dotstring representation of binary trees
We consider again binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67. Such a tree can be represented by the preorder sequence of its nodes in which dots (.) are inserted where an empty subtree (nil) is encountered during the tree traversal. For example, the tree shown in problem P67 is represented as "ABD..E..C.FG...". First, try to establish a syntax (BNF or syntax diagrams) and then write functions tree and dotstring which do the conversion.

:SOLUTION:
#+begin_src lisp
  (defun binary-tree-dotstring-encode (tree)
    (when tree
      (concatenate
       'string
       (symbol-name (car tree))
       (binary-tree-dotstring-encode (cadr tree))
       "."
       (binary-tree-dotstring-encode (caddr tree)))))

  (binary-tree-dotstring-encode
   '(a (b (d nil nil) (e nil nil)) (c nil (f (g nil nil) nil))))
#+end_src

#+RESULTS:
- ABD..E..C.FG..

There is only one deliminater to treat, and obviously, this representation only allows single-character symbols, so we can avoid the tokenizer, simply use ~coerce~ to explode the string. Compared to P67, this grammar is not linear. So here we will use a recursive descent parser. This representation is more natural in lisp. To control the head of parser there are common two ways, one is to save it in a context reference in argument, another is to save the state in return value. Here we prefer the first way, which is usually clearer.

#+begin_src lisp
  ;; BNF syntax:
  ;;
  ;; SYM ::= all single character that can be used as a Lisp symbol
  ;;
  ;; EXP ::= SYM EXP DOT EXP
  ;;       | SYM EXP DOT
  ;;       | SYM DOT EXP
  ;;       | SYM DOT
  ;;
  ;; we may simplify it as:
  ;;
  ;; EXP ::= SYM OPE DOT OPE
  ;; OPE ::= EXP | ϵ

  (defclass binary-tree-dotstring-parser ()
    ((tokens :initarg :tokens)
     (head :initarg :head :accessor head)
     (value :initarg :value :accessor value)))

  (defun parse-exp (parser)
    (when (and (head parser)
               (not (equal '|.| (car (head parser)))))
      ;; (print (value parser))
      (let ((node (list (intern (string (car (head parser)))) nil nil)))
        (push node (value parser)) ;; shift sym
        (setf (head parser) (cdr (head parser)))
        (parse-and-reduce-exp parser 'left) ;; maybe exp
        (when (not (equal '|.| (car (head parser)))) ;; match dot
          (error "syntax error at ~a" (head parser)))
        (setf (head parser) (cdr (head parser))) ;; shift dot
        (parse-and-reduce-exp parser 'right) ;; maybe exp
        node)))

  (defun parse-and-reduce-exp (parser direct)
    (when (parse-exp parser) ;; new exp value?
      (rplacd (cadr (value parser)) ;; reduce one
              (cond
                ((equal 'left direct)
                 (cons (car (value parser)) (cddr (cadr (value parser)))))
                ((equal 'right direct)
                 (list (cadr (cadr (value parser))) (car (value parser))))
                (t (error "invalid direction: ~a" direct))))
      (setf (value parser) (cdr (value parser)))))

  (defun binary-tree-dotstring-decode (s)
    (let* ((l (mapcar (lambda (c) (intern (string c)))
                      (coerce s 'list)))
           (parser (make-instance
                    'binary-tree-dotstring-parser
                    :tokens l :head l :value nil)))
      (parse-exp parser)
      (car (value parser))))

  ;; test
  (binary-tree-dotstring-decode "ABD..E..C.FG..")
#+end_src

#+RESULTS:
- (A (B (D NIL NIL) (E NIL NIL)) (C NIL (F (G NIL NIL) NIL)))

:END:
* Multiway Trees
** Introduction
A multiway tree is composed of a root element and a (possibly empty) set of successors which are multiway trees themselves. A multiway tree is never empty. The set of successor trees is sometimes called a forest.

In Lisp we represent a multiway tree by either a symbol (root with no children) or by an expression (X C1 C2 ... CN), where X denotes the root node and Ci denote each of the children. The following pictures show how multiway tree structures are represented in Lisp.


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p73.png
[[file:L99.assets/2025-12-06_11-27-56_p73.png]]


Note that in this Lisp notation a node with successors (children) in the tree is always the first element in a list, followed by its children.

** P70 (⋆⋆) Tree construction from a node string
We suppose that the nodes of a multiway tree contain single characters. In the depth-first order sequence of its nodes, a special character ^ has been inserted whenever, during the tree traversal, the move is a backtrack to the previous level.


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p70.gif
[[file:L99.assets/2025-12-06_11-29-32_p70.gif]]


By this rule, the tree in the figure opposite is represented as: afg^^c^bd^e^^^

Define the syntax of the string and write a function (tree string) to construct the tree when the string is given. Work with lists (instead of strings). Write also an inverse function.

:SOLUTION:
#+begin_src lisp
  (defun tree-encode (tree)
    (if (listp tree)
        (cons (car tree)
              (append (mapcan (lambda (x) (tree-encode x)) (cdr tree))
                      (list '^)))
        (list tree '^)))

  (tree-encode '(a (f g) c (b d e)))
#+end_src

#+RESULTS:
- (A F G ^ ^ C ^ B D ^ E ^ ^ ^)


#+begin_src lisp
  (defun tree-aux (l stack)
    (print stack)
    (cond
      ((equal (car l) '^)
       (if (cdr stack)
           (tree-aux (cdr l)
                   (cons (append (cadr stack) (list (car stack)))
                         (cddr stack)))
           (car stack)))
      (t
       (tree-aux (cdr l)
               (if (null stack)
                   (list (car l))
                   (cons (car l)
                         (if (symbolp (car stack))
                             (cons (list (car stack)) (cdr stack))
                             stack)))))))

  (defun tree (l) (tree-aux l nil))

  ;; test
  (tree '(A F G ^ ^ C ^ B D ^ E ^ ^ ^))
#+end_src

#+RESULTS:
- (A (F G) C (B D E))

:END:
** P70B (⋆) Check whether a given expression represents a multiway tree
Write a function istree which succeeds if and only if its argument is a Lisp expression representing a multiway tree.
Example:
  (istree '(a (f g) c (b d e)))
T

:SOLUTION:
#+begin_src lisp
  (defun istree-aux (l)
    (if (null l) t (and (istree (car l)) (istree-aux (cdr l)))))

  (defun istree (exp)
    (if (listp exp)
        (and (symbolp (car exp))
             (not (null (cdr exp)))
             (istree-aux (cdr exp)))
        (symbolp exp)))

  ;; test
  (mapcar
   #'istree
   (list nil 'a '(a) '(a b c) '(a (f g) c (b d e)))
   )
#+end_src

#+RESULTS:
- (NIL T NIL T T)

:END:
** P70C (⋆) Count the nodes of a multiway tree
Write a function nnodes which counts the nodes of a given multiway tree.
Example:
  (nnodes '(a f))
2

:SOLUTION:
#+begin_src lisp
  (defun nnodes (tree)
    (if (listp tree) (apply #'+ (mapcar #'nnodes tree)) 1))

  ;; test
  (mapcar
   #'nnodes
   (list 'a '(a b c) '(a (f g) c (b d e)))
   )
#+end_src

#+RESULTS:
- (1 3 7)

:END:
** P71 (⋆) Determine the internal path length of a tree
We define the internal path length of a multiway tree as the total sum of the path lengths from the root to all nodes of the tree. By this definition, the tree in the figure of problem P70 has an internal path length of 9. Write a function (ipl tree) to compute it.

:SOLUTION:
Note that internal path length is equal to the size summary of all subtrees.
Use ~nnodes~ defined in [[*P70C (⋆) Count the nodes of a multiway tree][P70C]]
#+begin_src lisp
  (defun ipl (tree)
    (if (listp tree)
        (+ (1- (nnodes tree)) (apply #'+ (mapcar #'ipl (cdr tree))))
        0))

  (mapcar
   #'ipl
   (list 'a '(a b c) '(a (f g) c (b d e)))
   )
#+end_src

#+RESULTS:
- (0 2 9)

:END:
** P72 (⋆) Construct the bottom-up order sequence of the tree nodes
Write a function (bottom-up mtree) which returns the bottom-up sequence of the nodes of the multiway tree mtree as a Lisp list.

:SOLUTION:
I am not sure if bottom-up order means a level order, but we have already met the postfix order problem in P70, so I guess this should be a bottom-up level order.

Here we use a cache-and-sort strategy: The first step is to grab all nodes with BFS, nodes in the same level are returned in left-to-right order. The second step is to sort the nodes with a sort algorithm (e. g. ~qsort~ defined in [[*P28 (⋆⋆) Sorting a list of lists according to length of sublists][P28]]) that won't exchange the order of nodes with the same weight.
#+begin_src lisp
  (defun bottom-up-aux (mtree depth)
    (if (listp mtree)
        (cons (cons depth (car mtree))
         (mapcan (lambda (x) (bottom-up-aux x (1+ depth))) (cdr mtree)))
        (list (cons depth mtree))))

  (defun bottom-up (mtree)
    (mapcar (lambda (x) (cdr x))
            (qsort (bottom-up-aux mtree 0) (lambda (x y) (> (car x) (car y))))))

  ;; test
  (mapcar
   #'bottom-up
   (list 'a '(a b c) '(a (f g) c (b d e)))
   )

#+end_src

#+RESULTS:
- ((A) (B C A) (G D E F C B A))

:END:
** P73 (⋆⋆) Prolog-like tree representation
There is a particular notation for multiway trees in Prolog. Prolog is a prominent functional programming language, which is used primarily for artificial intelligence problems. As such, it is one of the main competitors of Lisp. In Prolog everything is a term, just as in Lisp everything is a symbolic expression.


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p70.gif
[[file:L99.assets/2025-12-06_11-30-45_p70.gif]]


In Prolog we represent a multiway tree by a term t(X,F), where X denotes the root node and F denotes the forest of successor trees (a Prolog list). The example tree depicted opposite is represented by the following Lisp expression:

t(a,[t(f,[t(g,[])]),t(c,[]),t(b,[t(d,[]),t(e,[])])])

The Prolog representation of a multiway tree is a sequence of atoms, commas, parentheses "(" and ")", and brackets "[" and "]".which we shall collectively call "tokens". We can represent this sequence of tokens as a Lisp list; e.g. the Prolog expression t(a,[t(b,[]),t(c,[])]) could be represented as the Lisp list ( t "(" a "," "[" t "(" b "," "[" "]" ")" "," t "(" c "," "[" "]" ")" "]" ")" ). Write a function (tree-ptl expr) which returns the "Prolog token list" if the tree is given as an expression expr in the usual Lisp notation.

Example:
  (tree-ptl '(a b c))
( T "(" A "," "[" T "(" B "," "[" "]" ")" "," T "(" C "," "[" "]" ")" "]" ")" )
As a second, even more interesting exercise try to write the inverse conversion: Given the list PTL, construct the corresponding Lisp tree.

:SOLUTION:
#+begin_src lisp
  (defun tree-ptl (mtree)
    (when mtree
      (if (listp mtree)
          (nconc (list t "(" (car mtree) "," "[")
                 (nconc (tree-ptl (cadr mtree))
                        (mapcan (lambda (x) (cons "," (tree-ptl x)))
                                (cddr mtree)))
                 (list "]" ")"))
          (list t "(" mtree "," "[" "]" ")"))))

  ;; test
  (tree-ptl '(a (f g) c (b d e)))
#+end_src

#+RESULTS:
- (T "(" A "," "[" T "(" F "," "[" T "(" G "," "[" "]" ")" "]" ")" "," T "(" C
- "," "[" "]" ")" "," T "(" B "," "[" T "(" D "," "[" "]" ")" "," T "(" E ","
- "[" "]" ")" "]" ")" "]" ")")

Since this problem doesn't require a tokenizer, we work on symbols.  Still a simple recursive descent parser.
#+begin_src lisp
  ;; BNF grammar:
  ;;
  ;; EXP ::= t "(" SYM "," LIST ")"
  ;; LIST ::= "[" EXP? ( "," EXP )* "]"

  (defclass ptl-parser ()
    ((tokens :initarg :tokens)
     (head :initarg :head :accessor head)))

  (defmethod forward ((parser ptl-parser) n)
    (when (> n 0)
      (if (null (head parser))
          (error "Unterminated item!")
          (setf (head parser) (cdr (head parser))))
      (forward parser (1- n))))

  (defun compare-lists (l1 l2)
    (or (null l2)
        (and (not (null l1))
             (equal (car l1) (car l2))
             (compare-lists (cdr l1) (cdr l2)))))

  (defmethod match ((parser ptl-parser) &rest items)
    (let ((h (head parser))) (compare-lists h items)))

  (defmethod eat ((parser ptl-parser) &rest items)
    (when (apply #'match (cons parser items))
      (forward parser (length items))
      t))

  (defmethod syntax-error ((parser ptl-parser))
    (error "syntax error at ~a" (head parser)))

  ;; match-and-eat
  (defmethod meat ((parser ptl-parser) &rest items)
    (or (apply #'eat (cons parser items))
        (syntax-error parser)))

  (defun ptl-parse-exp (parser)
    (meat parser t "(")
    (let ((x (car (head parser))))
      (if (symbolp x)
          (progn
            (forward parser 1)
            (meat parser ",")
            (let ((l (ptl-parse-list parser)))
              (meat parser ")")
              (if l (cons x l) x)))
          (syntax-error parser))))

  (defun ptl-parse-list (parser)
    (meat parser "[")
    (cond
      ((eat parser "]") nil)
      (t
       (let ((l (list (ptl-parse-exp parser))))
         (loop while (not (eat parser "]"))
               do (eat parser ",")
                  (push (ptl-parse-exp parser) l))
         (nreverse l)))))

  (defun ptl-tree (exp)
    (let ((parser (make-instance 'ptl-parser :tokens exp :head exp)))
      (ptl-parse-exp parser)))

  ;; test
  (ptl-tree (tree-ptl '(a (f g) c (b d e))))
#+end_src

#+RESULTS:
- (A (F G) C (B D E))

:END:
* Graphs
** Introduction
A graph is defined as a set of nodes and a set of edges, where each edge is a pair of nodes.

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/graph1.gif
[[file:L99.assets/2025-12-06_11-31-48_graph1.gif]]

There are several ways to represent graphs in Lisp. One method is to represent the whole graph as one data object. According to the definition of the graph as a pair of two sets (nodes and edges), we may use the following Lisp expression to represent the example graph:

((b c d f g h k) ( (b c) (b f) (c f) (f k) (g h) ))

We call this graph-expression form. Note, that the lists are kept sorted, they are really sets, without duplicated elements. Each edge appears only once in the edge list; i.e. an edge from a node x to another node y is represented as (x y), the expression (y x) is not present. The graph-expression form is our default representation. In Common Lisp there are predefined functions to work with sets.

A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the adjacency-list form. In our example:

( (b (c f)) (c (b f)) (d ()) (f (b c k)) ...)

When the edges are directed we call them arcs. These are represented by ordered pairs. Such a graph is called directed graph. To represent a directed graph, the forms discussed above are slightly modified. The example graph opposite is represented as follows:

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/graph2.gif
[[file:L99.assets/2025-12-06_11-33-32_graph2.gif]]

Graph-expression form
( (r s t u v) ( (s r) (s u) (u r) (u s) (v u) ) )
Adjacency-list form
( (r ()) (s (r u)) (t ()) (u (r)) (v (u)) )
Note that the adjacency-list does not have the information on whether it is a graph or a digraph.

Finally, graphs and digraphs may have additional information attached to nodes and edges (arcs). For the nodes, this is no problem, as we can easily replace the single symbol identifiers with arbitrary symbolic expressions, such as ("London" 4711). On the other hand, for edges we have to extend our notation. Graphs with additional information attached to edges are called labelled graphs.

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/graph3.gif
[[file:L99.assets/2025-12-06_11-34-14_graph3.gif]]

Graph-expression form
( (k m p q) ( (m q 7) (p m 5) (p q 9) ) )
Adjacency-list form
( (k ()) (m ((q 7))) (p ((m 5) (q 9))) (q ()) )
Notice how the edge information has been packed into a list with two elements, the corresponding node and the extra information.

The notation for labelled graphs can also be used for so-called multi-graphs, where more than one edge (or arc) are allowed between two given nodes.
:END:
** P80 (⋆⋆⋆) Conversions
Write functions to convert between the different graph representations. With these functions, all representations are equivalent; i.e. for the following problems you can always pick freely the most convenient form. The reason this problem is rated (⋆⋆⋆) is not because it's particularly difficult, but because it's a lot of work to deal with all the special cases.

:SOLUTION:
For undirected, weighted graphs:
#+begin_src lisp
  (defun adjacent-list-form-udw (ge)
    (let ((vs (mapcar (lambda (v) (list v nil)) (car ge))))
      (mapc (lambda (e)
              (let ((left (assoc (car e) vs))
                    (right (assoc (cadr e) vs)))
                (rplacd left (list (cons (cdr e) (cadr left))))
                (rplacd right (list (cons (list (car e) (caddr e))
                                          (cadr right))))))
            (cadr ge))
      vs))

  ;; test
  (adjacent-list-form-udw '((K M P Q) ((M Q 7) (P Q 9) (P M 5))))
#+end_src

#+RESULTS:
- ((K NIL) (M ((P 5) (Q 7))) (P ((M 5) (Q 9))) (Q ((P 9) (M 7))))

#+begin_src lisp
  (defun graph-expression-form-udw (al)
    (list (mapcar (lambda (item) (car item)) al)
          (remove-duplicates
           (mapcan (lambda (item)
                     (mapcar (lambda (v) (cons (car item) v)) (cadr item)))
                   al)
           :test (lambda (e1 e2) (null (set-difference e1 e2))))))

  ;; test
  (graph-expression-form-udw '((K NIL) (M ((P 5) (Q 7))) (P ((M 5) (Q 9))) (Q ((P 9) (M 7)))))
#+end_src

#+RESULTS:
- ((K M P Q) ((P M 5) (Q P 9) (Q M 7)))

For directed, weighted graphs:
#+begin_src lisp
  (defun adjacent-list-form-dw (ge)
    (let ((vs (mapcar (lambda (v) (list v nil)) (car ge))))
      (mapc (lambda (e)
              (let ((item (assoc (car e) vs)))
                (rplacd item (list (cons (cdr e) (cadr item))))))
            (cadr ge))
      vs))

  ;; test
  (adjacent-list-form-dw '((K M P Q) ((M Q 7) (P Q 9) (P M 5))))
#+end_src

#+RESULTS:
- ((K NIL) (M ((Q 7))) (P ((M 5) (Q 9))) (Q NIL))

#+begin_src lisp
  (defun graph-expression-form-dw (al)
    (list (mapcar (lambda (item) (car item)) al)
          (mapcan (lambda (item)
                    (mapcar (lambda (adj) (cons (car item) adj)) (cadr item)))
                  al)))

  ;; test
  (graph-expression-form-dw '((K NIL) (M ((Q 7))) (P ((Q 9) (M 5))) (Q NIL)))
#+end_src

#+RESULTS:
- ((K M P Q) ((M Q 7) (P Q 9) (P M 5)))

For directed, unweighted graphs:
#+begin_src lisp
  (defun adjacent-list-form-duw (ge)
    (let ((vs (mapcar (lambda (v) (list v nil)) (car ge))))
      (mapc (lambda (e)
              (let ((item (assoc (car e) vs)))
                (rplacd item (list (cons (cadr e) (cadr item))))))
            (cadr ge))
      vs))

  ;; test
  (adjacent-list-form-duw '((K M P Q) ((M Q) (P Q) (P M))))
#+end_src

#+RESULTS:
- ((K NIL) (M (Q)) (P (M Q)) (Q NIL))

#+begin_src lisp
  (defun graph-expression-form-duw (al)
    (list (mapcar (lambda (item) (car item)) al)
          (mapcan (lambda (item)
                    (mapcar (lambda (v) (list (car item) v)) (cadr item)))
                  al)))

  ;; test
  (graph-expression-form-duw '((K NIL) (M (Q)) (P (Q M)) (Q NIL)))
#+end_src

#+RESULTS:
- ((K M P Q) ((M Q) (P Q) (P M)))

For undirected, unweighted graphs:
#+begin_src lisp
  (defun adjacent-list-form-uduw (ge)
    (let ((vs (mapcar (lambda (v) (list v nil)) (car ge))))
      (mapc (lambda (e)
              (let ((left (assoc (car e) vs))
                    (right (assoc (cadr e) vs)))
                (rplacd left (list (cons (cadr e) (cadr left))))
                (rplacd right (list (cons (car e) (cadr right))))))
            (cadr ge))
      vs))

  ;; test
  (adjacent-list-form-uduw '((K M P Q) ((M Q) (P Q) (P M))))
#+end_src

#+RESULTS:
- ((K NIL) (M (P Q)) (P (M Q)) (Q (P M)))

#+begin_src lisp
  (defun graph-expression-form-uduw (al)
    (list (mapcar (lambda (item) (car item)) al)
          (remove-duplicates
           (mapcan (lambda (item)
                     (mapcar (lambda (v) (list (car item) v)) (cadr item)))
                   al)
           :test (lambda (e1 e2) (null (set-difference e1 e2))))))

  ;; test
  (graph-expression-form-uduw '((K NIL) (M (P Q)) (P (Q M)) (Q (P M))))
#+end_src

#+RESULTS:
- ((K M P Q) ((P M) (Q P) (Q M)))

:END:
** P81 (⋆⋆) Path from one node to another one
Write a function (path g a b) to return an acyclic path from node a to node b in the graph g. The function should return all paths.

:SOLUTION:
Use BFS, here we use adjacent list form.
#+begin_src lisp
  (defun path-aux (g source sink prefix)
    (mapcan (lambda (adj)
              (if (equal adj sink)
                  (list (reverse (cons adj prefix)))
                  (path-aux g adj sink (cons adj prefix))))
            (cadr (assoc source g))))

  (defun path (g a b)
    (path-aux g a b (list a)))

  ;; test
  (path '( (r ()) (s (r u)) (t ()) (u (r)) (v (u)) ) 's 'r)
#+end_src

#+RESULTS:
- ((S R) (S U R))

:END:
** P82 (⋆) Cycle from a given node
Write a function (cycle g a) to find a closed path (cycle) starting at a given node a in the graph g. The function should return all cycles.

:SOLUTION:
Still BFS, with path record comparation.
#+begin_src lisp
  (defun cycle-aux (g sink prefix)
    (mapcan (lambda (adj)
              (if (member adj prefix)
                  ;; if not a cycle closed at sink, it is also dead.
                  (when (equal adj sink)
                    (list (reverse (cons adj prefix))))
                  (cycle-aux g sink (cons adj prefix))))
            (cadr (assoc (car prefix) g))))

  (defun cycle (g a)
    (cycle-aux g a (list a)))

  ;; test, this is an alternative graph
  (cycle '( (r (u)) (s (r u)) (t ()) (u (s)) (v (u)) ) 's)
#+end_src

#+RESULTS:
- ((S R U S) (S U S))

:END:
** P83 (⋆⋆) Construct all spanning trees
Write a function (s-tree graph) to construct (by backtracking) all spanning trees of a given graph. With this function, find out how many spanning trees there are for the graph depicted to the left. The data of this example graph can be found in the file [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p83.dat][p83.dat]]. When you have a correct solution for the s-tree function, use it to define two other useful functions: (is-tree graph) and (is-connected graph). Both are five-minutes tasks!

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p83.gif
[[file:L99.assets/2025-12-06_11-36-33_p83.gif]]

:SOLUTION:
Since the given example is an undirected graph in graph-expression form, we use graph-expression form to avoid conversions for adjacent-list form. Or, you may try ~undirected-conversion~ from [[*P88 (⋆⋆) Connected components][P88]].

If we don't consider much, we can simply use ~combination~ defined in [[*P26 (⋆⋆) Generate the combinations of K distinct objects chosen from the N elements of a list][P26]] to produce all possible edge combinations of size |V| - 1, then filter out all valid spanning trees. But this will cause an O(|E|!) algorithm.

However, if we try to do DFS or BFS, it may produce many duplicated trees as much as the O(|V|!) or O(|E|!), because the order of traverse doesn't affect the result. To solve this problem we play a trick of loop back. That is, when extending the set of the selected vertices ~vs~, we should treat it as a sequence and insert the new vertex into it (use ~range~ in [[*P22 (⋆) Create a list containing all integers within a given range.][P22]]).

#+begin_src lisp
  (defun cut (ge v)
    (mapcan (lambda (e) (when (member v e) (list e))) ge))

  (defun end (e v)
    (cond ((equal v (car e)) (cadr e))
          ((equal v (cadr e)) (car e))))

  (defun s-tree-aux (n ge sv se)
    (let ((v (car sv)))
      (mapcan
       (lambda (es)
         (let ((u (end (car es) v)))
           (when (not (member u sv))
             (if (= (length sv) (1- n)) ;; end condition
                 (list (list (cons u sv) (cons (car es) se)))
                 (mapcan
                  (lambda (vs)
                    (s-tree-aux n (set-difference ge es)
                                vs (cons (car es) se)))
                  (list (cons u sv)
                        (cons v (cons u (cdr sv)))))))))
       (let ((c (cut ge v)))
         ;; try all combinations of edges
         (mapcar (lambda (n) (nthcdr n c))
                 (range 0 (1- (length c))))))))

  (defun s-tree (g)
    (mapcan (lambda (v)
              (s-tree-aux (length (car g)) (cadr g) (list v) nil))
            (car g)))

  (let ((p83-dat
          '((a b c d e f g h)
            ((a b) (a d) (b c) (b e) (c e) (d e) (d f) (d g) (e h) (f g) (g h)))))
    (length (s-tree p83-dat))
    )
#+end_src

#+RESULTS:
- 172

Actually this algorithm is not that efficient, because it use ~set-difference~ to filter out edges. If we want to be more efficient for non-sparse graphs, we may use a disjoint set for recording selected edges (see solution for P88). The complexity of ~s-tree-aux~ is related to total number of spanning trees in graph, we have an obvious upper bound O(|V|^(|V|-2)) for corresponding complete graph.

To calculate the total number of spanning trees, there is actually a faster method, by Kirchhoff's theorem: let G be a graph with n+1 vertices, λ₁, λ₂, ..., λₙ be eigenvalues of its Laplacian matrix, the number of spanning trees in G, let it be t(G), is determined by equation (n+1)t(G) = λ₁λ₂ ... λₙ. To solve the eigenvalues, we only need to do LU decomposition on it, which takes Ω(|V|^3).

For ~is-tree~ and ~is-connected~, in an undirected graph, these two functions are equivalent. You can find a more efficient solution for ~is-connected~ in [[*P88 (⋆⋆) Connected components][P88]]. For a directed graph, DFS works well.

:END:
** P84 (⋆⋆) Construct a minimum spanning tree
Write a function (ms-tree graph) to construct a minimum spanning tree of a given labelled graph. The function must also return the minimum weight. Hint: Use the algorithm of Prim. A small modification of the solution of P83 does the trick. The data of the example graph to the right can be found in the file [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p84.dat][p84.dat]].

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p84.gif
[[file:L99.assets/2025-12-06_11-37-12_p84.gif]]

:SOLUTION:
Prim's algorithm always pick the edge with minimal cost in the cut of picked vertices.

#+begin_src lisp
  (defun end-vs (e vs)
    (cond ((member (car e) vs) (cadr e))
          ((member (cadr e) vs) (car e))))

  (defun cut-vs (ge vs)
    (let ((inner) (outer))
      (mapc
       (lambda (e)
         (let ((flag1 (member (car e) vs))
               (flag2 (member (cadr e) vs)))
           (if (and flag1 flag2)
               (push e inner)
               (when (or flag1 flag2)
                 (push e outer)))))
       ge)
      (values inner outer)))

  (defun min-es (ec)
    (reduce (lambda (m e) (if (<= (caddr m) (caddr e)) m e)) ec))

  (defun prim-aux (n ge sv se)
    (if (= (length sv) n)
        (list (list sv se))
        (multiple-value-bind (inner outer)
            (cut-vs ge sv)
          (let ((e (min-es outer)))
            (when e
              (let ((v (end-vs e sv)))
                (prim-aux n (set-difference ge inner)
                          (cons v sv) (cons e se))))))))

  (defun prim (g &aux (start (caar g)))
    (prim-aux (length (car g)) (cadr g) (list start) nil))

  (let ((p84-dat '((a b c d e f g h) ((a b 5) (a d 3) (b c 2) (b e 4) (c e 6) (d e 7) (d f 4) (d g 3) (e h 5) (f g 4) (g h 1)))))
    (prim p84-dat))
#+end_src

#+RESULTS:
- (((E C B F H G D A) ((B E 4) (B C 2) (A B 5) (F G 4) (G H 1) (D G 3) (A D 3))))

Actually previous implementation is of low efficiency because it recomputes inner and outer edges in each recursion step. To have a better performance, the simplest way is to use a hash table to mark if a vertex has been visited. Besides, ~min-es~ will traverse all outer edges in each recursion step to find the minimal edge, which got a lot of repeated visits. To resolve this problem we may maintain outer edges in a heap, so that we don't need to recompute it. The total cost is O(|V|log|E| + |E|log|E|).  Maybe you have solved this problem in this style? That is bravo!

Here is another implement based on leftist tree. The reason why we use leftist tree is that it only includes tree operations, so it is relatively simpler to implement in Lisp. A binary tree usually have better performance, but it works on an array with pointer arithmetics.

#+begin_src lisp
  (defstruct ltree-node value left right (rank 0))

  (defun ltree-rank (node)
    (if node (ltree-node-rank node) -1))

  (defclass ltree ()
    ((root :accessor root :initarg :root :type ltree-node)))

  (defun ltree-merge (n1 n2 predicate)
    (cond
      ((null n1) n2)
      ((null n2) n1)
      ((funcall predicate n2 n1) (ltree-merge n2 n1 predicate))
      (t
       (setf (ltree-node-right n1)
             (ltree-merge (ltree-node-right n1) n2 predicate))
       (let ((lch (ltree-node-left n1))
             (rch (ltree-node-right n1)))
         (when (< (ltree-rank lch) (ltree-rank rch))
           (rotatef (ltree-node-left n1) (ltree-node-right n1)))
         (setf (ltree-node-rank n1)
               (1+ (if lch (ltree-rank (ltree-node-right n1)) 0))))
       n1)))

  (defun little-edge-p (n1 n2)
    (< (caddr (ltree-node-value n1)) (caddr (ltree-node-value n2))))

  (defmethod insert ((heap ltree) value)
    (setf (root heap)
          (ltree-merge (root heap)
                       (make-ltree-node :value value)
                       #'little-edge-p)))

  (defmethod extract ((heap ltree))
    (when (root heap)
      (let ((n (root heap)))
        (setf (root heap)
              (ltree-merge (ltree-node-left n) (ltree-node-right n) #'little-edge-p))
        (ltree-node-value n))))

  (defun adjacent-hash-table-form (g)
    (let ((h (make-hash-table)))
      (mapc (lambda (e)
              (let ((v1 (car e)) (v2 (cadr e)) (w (caddr e)))
                (setf (gethash v1 h) (cons (list v2 w) (gethash v1 h))
                      (gethash v2 h) (cons (list v1 w) (gethash v2 h)))))
            (cadr g))
      h))

  (defun prim-1-aux (hg heap sv se visited)
    (let ((e (extract heap)))
      (if (null e)
          ;; no more edges in cut, an MST is found
          (list sv (butlast se))
          (progn
            ;; skip inner edges
            (when (not (gethash (cadr e) visited))
              (let ((u (car e))
                    (v (cadr e)))
                ;; add min in cut
                (push v sv)
                (push e se)
                (setf (gethash v visited) t)
                ;; add unvisited neighbors to heap
                (mapc (lambda (a)
                        (unless (gethash (car a) visited)
                          (insert heap (cons v a))))
                      (gethash v hg))))
            ;; recursion
            (prim-1-aux hg heap sv se visited)))))

  (defun prim-1 (g &aux (start (caar g)))
    (let ((hg (adjacent-hash-table-form g))
          (heap (make-instance 'ltree :root (make-ltree-node :value (list nil start 0))))
          (visited (make-hash-table)))
      (prim-1-aux hg heap nil nil visited)))

  (let ((p84-dat '((a b c d e f g h) ((a b 5) (a d 3) (b c 2) (b e 4) (c e 6) (d e 7) (d f 4) (d g 3) (e h 5) (f g 4) (g h 1)))))
    (prim-1 p84-dat))
#+end_src

#+RESULTS:
- ((C B E F H G D A) ((B C 2) (E B 4) (H E 5) (D F 4) (G H 1) (D G 3) (A D 3)))

For Lisp, I think Kruskal's algorithm may be more natural, which finds a pair of roots with minimal connection cost to merge on a forest of MSTs, this can be implemented by firstly sorting all edges, and then try to add edges one by one. To detect if the edge can be added, we may use a disjoint set to check this. However, to implement a efficient disjoint set, we still need to use an array. Kruskal's algorithm is not as straight as Prim's algorithm, but it's usually more straight to implement.

:END:
** P85 (⋆⋆) Graph isomorphism
Two graphs (n1 e1) and (n2 e2) are isomorphic if there is a bijection f: n1 -> n2 such that for any nodes x,y of n1, x and y are adjacent if and only if f(x) and f(y) are adjacent.
Write a function that determines whether two graphs are isomorphic. Hint: Use an open-ended list to represent the function f.

:SOLUTION:
The definition is for undirected graph, for directed graph it has more strict version which requires for each edge (x y) in g1 there exists edge (f(x) f(y)) in g2. Here we only solve the problem for undirected graph.

We use the same strategy as Prim's algorithm, maintaining the vertex map on the inner cut for each extended vertex pair, until we traverse all vertices. This algorithm only work for connected graphs, for non-connected graphs, we may test all permutations of its connected components as well.
#+begin_src lisp
  (defun degree-list (g)
    (let ((l)
          (h (make-hash-table)))
      (mapc (lambda (v)
              (setf (gethash v h) 0))
            (car g))
      (mapc (lambda (e)
              (incf (gethash (car e) h))
              (incf (gethash (cadr e) h)))
            (cadr g))
      (maphash (lambda (_ v) (push v l)) h)
      l))

  ;; In the worst case, we compute all possible inner cuts in graph.
  ;; There may be a wiser way to compute these inner cuts ...
  (defun inner-cut (ge vs v)
    (mapcan (lambda (e)
              (when (or
                     (and (equal (cadr e) v) (member (car e) vs))
                     (and (equal (car e) v) (member (cadr e) vs)))
                (list e)))
            ge))

  ;; check if f is a valid isomorphism by definition
  (defun isomorphism-p (g1 g2 f)
    (and (= (length (cadr g1)) (length (cadr g2)))
         ;; for each adjacent v1 v2, there exists adjacent fv1 fv2
         (every (lambda (e)
                  (let ((fv1 (cdr (assoc (car e) f)))
                        (fv2 (cdr (assoc (cadr e) f))))
                    (or (member (list fv1 fv2) (cadr g2) :test #'equal)
                        (member (list fv2 fv1) (cadr g2) :test #'equal))))
                (cadr g1))))

  ;; this function finds out all isomorphisms
  (defun isomorphism-aux (g1 g2 f)
    (if (null (car g1))
        (list f)
        (let ((v1 (caar g1))
              (vs1 (mapcar (lambda (cons) (car cons)) f))
              (vs2 (mapcar (lambda (cons) (cdr cons)) f)))
          (let ((ies1 (inner-cut (cadr g1) vs1 v1)))
            (mapcan
             (lambda (v2)
               ;; test if f(v1) = v2 is valid on inner cut
               (let ((ies2 (inner-cut (cadr g2) vs2 v2)))
                 (when (isomorphism-p (list (cons v1 vs1) ies1)
                                      (list (cons v2 vs2) ies2)
                                      (cons (cons v1 v2) f))
                   (isomorphism-aux
                    (list (remove v1 (car g1)) (set-difference (cadr g1) ies1))
                    (list (remove v2 (car g2)) (set-difference (cadr g2) ies2))
                    (cons (cons v1 v2) f)))))
             (car g2))))))

  ;; this function finds out one and stop
  (defun isomorphism-aux-1 (g1 g2 f)
    (if (null (car g1))
        (list f)
        (let ((v1 (caar g1))
              (vs1 (mapcar (lambda (cons) (car cons)) f))
              (vs2 (mapcar (lambda (cons) (cdr cons)) f)))
          (let ((ies1 (inner-cut (cadr g1) vs1 v1)))
            (some
             (lambda (v2)
               ;; test if f(v1) = v2 is valid on inner cut
               (let ((ies2 (inner-cut (cadr g2) vs2 v2)))
                 (when (isomorphism-p (list (cons v1 vs1) ies1)
                                      (list (cons v2 vs2) ies2)
                                      (cons (cons v1 v2) f))
                   (isomorphism-aux-1
                    (list (remove v1 (car g1)) (set-difference (cadr g1) ies1))
                    (list (remove v2 (car g2)) (set-difference (cadr g2) ies2))
                    (cons (cons v1 v2) f)))))
             (car g2))))))

  (defun isomorphism (g1 g2)
    (cond
      ;; isomorphic graphs have the same number of nodes
      ;; O(V₁ + V₂)
      ((not (= (length (car g1)) (length (car g2)))) nil)
      ;; isomorphic graphs have the same number of edges
      ;; O(E₁ + E₂)
      ((not (= (length (cadr g1)) (length (cadr g2)))) nil)
      ;; isomorphic graphs have the same number of degrees
      ;; O(V² + E)
      ((set-difference (degree-list g1) (degree-list g2)) nil)
      ;; finally, try to find a mapping
      ;; O(E × V!)
      (t (isomorphism-aux-1 g1 g2 nil))))

  (isomorphism '((X Y Z) ((X Y) (X Z) (Y Z)))
               '((A B C) ((A C) (B C) (A B))))
#+end_src

#+RESULTS:
- (((Z . C) (Y . B) (X . A)))

~set-difference~ may be slow here, to accelerate edge filtering, we may use an array to mark selected edges.
:END:
** P86 (⋆⋆) Node degree and graph coloration
a) Write a function (degree graph node) that determines the degree of a given node.
b) Write a function that generates a list of all nodes of a graph sorted according to decreasing degree.
c) Use Welch-Powell's algorithm to paint the nodes of a graph in such a way that adjacent nodes have different colors.

:SOLUTION:
a) This is too simple for a adjacent list form.
#+begin_src lisp
  (defun degree (g n)
    (length (cadr (assoc n g))))
#+end_src

b)
#+begin_src lisp
  (defun degree-sort (g)
    (mapcar
     (lambda (x) (assoc (cdr x) g))
     (sort (mapcar (lambda (adj) (cons (length (cadr adj)) (car adj))) g)
           #'> :key #'car)))

  ;; test
  (let ((p83-dat '((a (b d)) (b (c e)) (c (b e)) (d (a e f)) (e (b c d h)) (f (d g)) (g (d f h)) (h (e g)))))
    (degree-sort p83-dat))
#+end_src

#+RESULTS:
- ((E (B C D H)) (D (A E F)) (G (D F H)) (A (B D)) (B (C E)) (C (B E)) (F (D G))
- (H (E G)))

c)
Welsh–Powell Algorithm consists of the following steps:
1. Find the degree of each vertex. (solved in a)
2. List the vertices in order of descending degrees. (solved in b)
3. Colour the first vertex with colour 1.
4. Move down the list and colour all the vertices that are not adjacent to the coloured vertex with the same colour.
5. Repeat Step 4 on all uncoloured vertices with a new colour, in descending order of degrees, until all the vertices are coloured.

#+begin_src lisp
  (defun welsh-powell-aux (color l nc)
    (let ((cur (car l)))
      (unless (gethash (car cur) color)
        (setf (gethash (car cur) color) nc)
        (mapc
         (lambda (adj)
           (unless (member (car adj) (cadr cur))
             (setf (gethash (car adj) color) nc)))
         (cdr l)))
      (when (cdr l)
        (welsh-powell-aux color (cdr l) (1+ nc)))))

  (defun welsh-powell (g)
    (let ((color (make-hash-table))
          (l (degree-sort g)))
      (welsh-powell-aux color l 1)
      (let ((output))
        (maphash (lambda (k v) (push (cons k v) output)) color)
        output)))

  ;; test
  (let ((p83-dat '((a (b d)) (b (c e)) (c (b e)) (d (a e f)) (e (b c d h)) (f (d g)) (g (d f h)) (h (e g)))))
    (welsh-powell p83-dat))
#+end_src

#+RESULTS:
- ((H . 2) (C . 2) (B . 2) (D . 2) (F . 1) (A . 1) (G . 2) (E . 1))

:END:
** P87 (⋆⋆) Depth-first order graph traversal
Write a function that generates a depth-first order graph traversal sequence. The starting point should be specified, and the output should be a list of nodes that are reachable from this starting point (in depth-first order).

:SOLUTION:
To do cycle detection, we maintain a hash table to mark traveled nodes.
#+begin_src lisp
  (defun graph-dfs-aux (g s h)
    (unless (gethash s h)
      ;; first mask it
      (setf (gethash s h) t)
      ;; then search its children
      (cons s (loop for v in (cadr (assoc s g))
                    append (graph-dfs-aux g v h)))))

  (defun graph-dfs (g s)
    (graph-dfs-aux g s (make-hash-table)))

  ;; test
  (let ((p83-dat '((a (b d)) (b (c e)) (c (b e)) (d (a e f)) (e (b c d h)) (f (d g)) (g (d f h)) (h (e g)))))
    (graph-dfs p83-dat 'a))
#+end_src

#+RESULTS:
- (A B C E D F G H)

:END:
** P88 (⋆⋆) Connected components
Write a function that splits a graph into its connected components.

:SOLUTION:
A connected component can be extracted by simple tree travel, for example, ~graph-dfs~ we implemented in [[*P87 (⋆⋆) Depth-first order graph traversal][P87]]. To use that function, we need to do some conversion for undirected graphs, use conversion functions in [[*P80 (⋆⋆⋆) Conversions][P80]].

#+begin_src lisp
  ;; convert a directed graph in adjacent form to equivalent undirected graph
  (defun undirected-conversion (g)
    (adjacent-list-form-uduw
     (graph-expression-form-uduw g)))

  (defun connected-components (g)
    (let ((h (make-hash-table)))
      (mapcan (lambda (c) (when c (list c)))
              (mapcar (lambda (adj) (graph-dfs-aux g (car adj) h)) g))))

  ;; test
  (connected-components
   (undirected-conversion '( (r (u)) (s (r u)) (t ()) (u (s)) (v (u)) )))
#+end_src

#+RESULTS:
- ((R S U V) (T))

However, there is a more efficient solution. We may use a disjoint set to mark all reachable vertices from one vertex. Since lisp uses symbols rather than numbers to represent vertices, to use the disjoint set, we need to implement the transformation between numbers and vertices. To be simpler, we work on graph expression form. The complexity of disjoint set is the inverse of Ackermann function, which grows extremely slow. However, a disjoint set does not provide the result, if we want to extract the result, it still has the same complexity as DFS (at first I didn't aware it).
#+begin_src lisp
  (defclass disjoint-set ()
    ((parent :accessor parent :initarg :parent)
     (rank :accessor rank :initarg :rank)))

  (defun make-disjoint-set (size)
    (let ((pa (make-array size))
          (ra (make-array size :initial-element 1)))
      (loop for i from 0 below size
            do (setf (aref pa i) i))
      (make-instance 'disjoint-set :parent pa :rank ra)))

  (defmethod root ((djs disjoint-set) i)
    (let ((p (aref (parent djs) i)))
      (if (= p i)
          p
          ;; path compression
          (setf (aref (parent djs) i) (root djs p)))))

  (defmethod unite ((djs disjoint-set) i j)
    (let ((ri (root djs i))
          (rj (root djs j)))
      (unless (= ri rj) ;; already in the same set
        (let ((ranki (aref (rank djs) i))
              (rankj (aref (rank djs) j)))
          (if (= ranki rankj)
              (setf (aref (parent djs) rj) i
                    (aref (rank djs) ri) (1+ ri))
              (if (> ranki rankj)
                  (setf (aref (parent djs) rj) i)
                  (setf (aref (parent djs) ri) j)))))))

  (defun compute-disjoint-set (g)
    (let* ((len (length (car g)))
           (djs (make-disjoint-set len)))
      ;; unite all edges
      (mapc (lambda (e) (unite djs (car e) (cadr e)))
            (cadr g))
      djs))

  (defun vertex-number-map (g)
    (let* ((len (length (car g)))
           (v2n (make-hash-table)) ;; map from vertex to number
           (n2v (make-array len))) ;; reverse map
      ;; encode vertices for v2n
      (loop for i from 0 below len
            for v in (car g)
            do (setf (gethash v v2n) i)
               (setf (aref n2v i) v))
      ;; return maps
      (list v2n n2v)))

  (defun number-conversion (v2n g)
    (list
     (mapcar (lambda (v) (gethash v v2n)) (car g))
     (mapcar (lambda (e)
               (list (gethash (car e) v2n)
                     (gethash (cadr e) v2n)))
             (cadr g))))

  (defun vertex-conversion (n2v g)
    (list
     (mapcar (lambda (i) (aref n2v i)) (car g))
     (mapcar (lambda (p)
               (list (aref n2v (car p))
                     (aref n2v (cadr p))))
             (cadr g))))

  (defun connected-components-1 (g)
    (let* ((vnmap (vertex-number-map g))
           (v2n (car vnmap))
           (n2v (cadr vnmap))
           (ng (number-conversion v2n g))
           (djs (compute-disjoint-set ng))
           (len (length (parent djs)))
           (abel (make-array len :initial-element nil)))
      ;; unify roots in djs, this step is necessary
      (loop for i from 0 below len
            do (setf (aref (parent djs) i) (root djs i)))
      ;; collect components by Abel transformation
      (loop for i from 0 below len
            for j = (aref (parent djs) i)
            do (setf (aref abel j)
                     (list (cons i (car (aref abel j))))))
      (loop for p in (cadr ng)
            for j = (aref (parent djs) (car p))
            do (rplacd (aref abel j)
                       (list (cons p (cadr (aref abel j))))))
      ;; recover numbers to vertices
      (mapcan (lambda (sg)
                (when sg (list (vertex-conversion n2v sg))))
              (map 'list #'identity abel))))

  ;; test
  (connected-components-1 '((r s t u v) ((r s) (s u) (u v) (u r))))
#+end_src

#+RESULTS:
- (((V U S R) ((U R) (U V) (S U) (R S))) ((T) NIL))

:END:
** P89 (⋆⋆) Bipartite graphs
Write a function that finds out whether a given graph is bipartite.

:SOLUTION:
Obviously, use the ~welsh-powell~ in [[*P86 (⋆⋆) Node degree and graph coloration][P86]], if the given graph can be colored in exactly two colors, obviously it is bipartite.
#+begin_src lisp
  (defun bipartite-graph-p (g)
    (let ((color (welsh-powell g)))
      (= 2 (apply #'max (mapcar (lambda (c) (cdr c)) color)))))

  ;; test
  (let ((p83-dat '((a (b d)) (b (c e)) (c (b e)) (d (a e f)) (e (b c d h)) (f (d g)) (g (d f h)) (h (e g)))))
    (bipartite-graph-p p83-dat))
#+end_src

#+RESULTS:
- T

* Miscellaneous Problems
** P90 (⋆⋆) Eight queens problem
This is a classical problem in computer science. The objective is to place eight queens on a chessboard so that no two queens are attacking each other; i.e., no two queens are in the same row, the same column, or on the same diagonal.

Hint: Represent the positions of the queens as a list of numbers 1..N. Example: (4 2 7 3 6 8 5 1) means that the queen in the first column is in row 4, the queen in the second column is in row 2, etc. Use the generate-and-test paradigm.

:SOLUTION:
The aim of this problem is to train your ability to write search programs with backtracking. However, for queen problems, there are indeed a simple way to construct a specific solution for arbitrary N. So we need to find all possible solutions.

In Lisp, backtracking can be achieved mainly in 3 ways:
1. keep states in arguments and recursive descent (DFS-style)
2. keep states in return value for recursive bounding (BFS-style)
3. keep states in expressions and evaluate them wisely (model & heuristics)

The fact is that, searching programs usually can not be written in style 2 because we usually do not know if there is a initial bound, so style 1 is preferred. As for style 3, it is ideal but only possible for some lunatic programmer to achieve, and the code is not readable for newbies at all.
#+begin_src lisp
  (defun queen-diag-safe-p (n i queens)
    (or
     (null queens)
     (and
      (loop for j from (1- i) downto 1 for y in queens never (= y j))
      (loop for j from (1+ i) to n for y in queens never (= y j))
      )))

  (defun queen-aux (n col queens avail-rows)
    (if (null avail-rows)
        (list queens)
        (mapcan (lambda (i)
                  (when (queen-diag-safe-p n i queens)
                    (queen-aux n (1+ col) (cons i queens)
                               (remove i avail-rows))))
                avail-rows)))

  (defun queen (n)
    (queen-aux n 1 nil (loop for i from 1 to n collect i)))

  ;; test, (queen 8) should have 11 * 8 + 1 * 4 = 92 answers.
  (length (queen 8))
#+end_src

#+RESULTS:
- 92

:END:
** P91 (⋆⋆) Knight's tour
Another famous problem is this one: How can a knight jump on an NxN chessboard in such a way that it visits every square exactly once?

Hints: Represent the squares by pairs of their coordinates of the form (X Y), where both X and Y are integers between 1 and N. Define a function (jump N (X Y)) that returns a list of the positions (U V) such that a knight can jump from (X Y) to (U V) on a NxN chessboard. And finally, represent the solution of our problem as a list of N*N knight positions (the knight's tour).

:SOLUTION:
This is actually a Hamiltonian path problem on square board.

Use ~range~ defined in [[*P22 (⋆) Create a list containing all integers within a given range.][P22]].
#+begin_src lisp
  ;; simple program to find out all solutions
  (defun jump (n xy)
    (mapcan
     (lambda (move)
       (let ((u (+ (car xy) (car move)))
             (v (+ (cdr xy) (cdr move))))
         (when (and (<= 1 u n) (<= 1 v n))
           (list (cons u v)))))
     ;; the order of jump test actually matters for knight-tour-1
     ;; if you got stuck, you may try to exchange these moves ...
     '((2 . 1) (1 . 2) (-1 . 2) (-2 . 1)
       (-2 . -1) (-1 . -2) (1 . -2) (2 . -1))))

  (defun knight-tour-aux (n path)
    (if (= (length path) (* n n))
        (list path)
        (mapcan (lambda (uv)
                  (when (not (member uv path :test #'equal))
                    (knight-tour-aux n (cons uv path))))
                (jump n (car path)))))

  (defun knight-tour (n)
    (mapcan
     (lambda (start) (knight-tour-aux n (list start)))
     (mapcan (lambda (y) (mapcar (lambda (x) (cons x y)) (range 1 n)))
             (range 1 n))))

  ;; test, it takes a while
  (length (knight-tour 5))
#+end_src

#+RESULTS:
- 1728

It will take a lot of time to find out all solutions when n > 5, let's write a faster program, which stops when one solution is found. Here we defined a macro ~with-board-set~ for simplicity, evaluate first to avoid warnings.

#+begin_src lisp
  (defmacro with-board-set (board xy body)
    `(let ((res) (x (car ,xy)) (y (cdr ,xy)))
       (setf (aref ,board x y) t)
       (setf res ,body)
       (setf (aref ,board x y) nil)
       res))

  (defun knight-tour-1 (n)
    (let ((board (make-array (list (1+ n) (1+ n)) :initial-element nil))
          (jump-net (make-array (list (1+ n) (1+ n))))
          (maxlen (* n n)))
      ;; pre-calculate all jumps in jump-net
      (mapc (lambda (y)
              (mapc (lambda (x)
                      (setf (aref jump-net x y) (jump n (cons x y))))
                    (range 1 n)))
            (range 1 n))
      (labels
          (;; Heuristic: prefer nodes that nearest to corners
           ;; this works well for n=7, 8, 9, bad for 10
           (heuristic (l)
             (sort l #'> :key (lambda (c)
                                (+ (expt (- (/ (1+ n) 2) (car c)) 2)
                                   (expt (- (/ (1+ n) 2) (cdr c)) 2)))))
           ;; define the recursive function in lexical closure
           (knight-tour-1-aux (len path)
             (if (= len maxlen)
                 path
                 (some
                  (lambda (uv)
                    (when (not (aref board (car uv) (cdr uv)))
                      (with-board-set board uv
                        (knight-tour-1-aux (1+ len) (cons uv path)))))
                  (let ((xy (car path)))
                    (heuristic (aref jump-net (car xy) (cdr xy))))))))
        ;; search from every possible (X . Y) as start
        (some (lambda (xy)
                (with-board-set board xy (knight-tour-1-aux 1 (list xy))))
              (mapcan (lambda (y) (mapcar (lambda (x) (cons x y)) (range 1 n)))
                      (range 1 n))))))

  ;; test
  (knight-tour-1 8)
#+end_src

#+RESULTS:
- ((6 . 5) (4 . 4) (3 . 6) (5 . 5) (4 . 3) (5 . 1) (6 . 3) (8 . 4) (7 . 2)
- (6 . 4) (4 . 5) (5 . 3) (3 . 4) (4 . 6) (5 . 4) (3 . 3) (5 . 2) (7 . 1)
- (8 . 3) (7 . 5) (5 . 6) (3 . 5) (4 . 7) (2 . 8) (1 . 6) (2 . 4) (1 . 2)
- (3 . 1) (2 . 3) (1 . 5) (2 . 7) (4 . 8) (6 . 7) (8 . 8) (7 . 6) (6 . 8)
- (8 . 7) (6 . 6) (5 . 8) (7 . 7) (8 . 5) (7 . 3) (8 . 1) (6 . 2) (4 . 1)
- (2 . 2) (1 . 4) (2 . 6) (1 . 8) (3 . 7) (2 . 5) (1 . 7) (3 . 8) (5 . 7)
- (7 . 8) (8 . 6) (7 . 4) (8 . 2) (6 . 1) (4 . 2) (2 . 1) (1 . 3) (3 . 2)
- (1 . 1))

Maybe we can try to randomly select the start point ... (1 . 1) is not a good start for some n.

:END:
** P92 (⋆⋆⋆) Von Koch's conjecture
Several years ago I met a mathematician who was intrigued by a problem for which he didn't know a solution. His name was Von Koch, and I don't know whether the problem has been solved since.[fn:1]

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p92a.gif
[[file:L99.assets/2025-12-06_11-39-18_p92a.gif]]


#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p92b.gif
[[file:L99.assets/2025-12-06_11-39-25_p92b.gif]]

Anyway the puzzle goes like this: given a tree with N nodes (and hence N-1 edges), find a way to enumerate the nodes from 1 to N and, accordingly, the edges from 1 to N-1 in such a way that, for each edge K, the difference of its node numbers equals K. The conjecture is that this is always possible.

For small trees the problem is easy to solve by hand. However, for larger trees, and 14 is already very large, it is extremely difficult to find a solution. And remember, we don't know for sure whether there is always a solution!

Write a function that calculates a numbering scheme for a given tree. What is the solution for the larger tree pictured above?

:SOLUTION:
This problem seems like a strong form of graceful tree conjecture, or Ringei-Kotzig conjecture. It was firstly researched in 20th century 60s, but still remains unsolved in mathematics now.

In description the examples are all undirected graphs.  We may suppose the input is converted to a directed graph rather than a multi-way tree.

We try to assign labels by DFS, on each step we try to identify the label of some edges by vertices. Once we found two edges have the same label, we can abort previous assignment and then do backtracking.

Use ~cut~ and ~end~ from [[*P83 (⋆⋆) Construct all spanning trees][P83]], also use ~range~ from [[*P22 (⋆) Create a list containing all integers within a given range.][P22]]. This implementation is not very efficient (it may take seconds to compute the example case), you may have a better implementation with alternative representation of the adjacent list.
#+begin_src lisp
  (defun mtree-nodes (tree)
    (cond
      ((null tree))
      ((listp tree)
       (cons (car tree) (mapcan #'mtree-nodes (cdr tree))))
      (t (list tree))))

  (defun mtree-edges (tree)
    (cond
      ((null tree))
      ((listp tree)
       (nconc (mapcar (lambda (x)
                        (list (car tree) (if (listp x) (car x) x)))
                      (cdr tree))
              (mapcan #'mtree-edges (cdr tree))))))

  (defun mtree-to-graph (tree)
    (list (mtree-nodes tree) (mtree-edges tree)))

  (defun von-koch (tree)
    (let* ((g (mtree-to-graph tree))
           (n (length (car g)))
           (ge (cadr g))
           (va (make-hash-table))
           (ea (make-array n :initial-element nil)))
      (labels
          ((von-koch-aux (vs ns)
             (if (null vs)
                 (let ((res))
                   (maphash (lambda (k v) (push (cons k v) res)) va)
                   res)
                 (some
                  (lambda (i)
                    (let ((res) (ws) (v (car vs)))
                      (setf (gethash v va) i)
                      ;; try to assign labels on all neighbor vertices,
                      ;; check if each edge has a unique value to assign
                      (when (every
                             (lambda (e)
                               (let ((j (gethash (end e v) va)))
                                 (or (not j) ;; not assigned
                                     (let ((w (abs (- i j))))
                                       (unless (aref ea w)
                                         (setf ws (cons w ws))
                                         (setf (aref ea w) t))))))
                             (cut ge v))
                        ;; descent on next vertex
                        (setf res (von-koch-aux (cdr vs) (remove i ns)))
                        ;; recover states of EA and VA for backtracking
                        (mapc (lambda (w) (setf (aref ea w) nil)) ws))
                      (setf (gethash v va) nil)
                      res))
                  ns))))
        (von-koch-aux (car g) (range 1 n)))))

  ;; test
  (von-koch '(a (b (e f) c) d g))
  (von-koch '(a b g i h (c (d k) f (e (q m (n p))))))
#+end_src

#+RESULTS:
- ((P . 10) (N . 8) (M . 7) (Q . 12) (E . 5) (F . 6) (K . 9) (D . 3) (C . 14)
- (H . 13) (I . 11) (G . 4) (B . 2) (A . 1))

:END:
** P93 (⋆⋆⋆) An arithmetic puzzle
Given a list of integer numbers, find a correct way of inserting arithmetic signs (operators) such that the result is a correct equation. Example: With the list of numbers (2 3 5 7 11) we can form the equations 2-3+5+7 = 11 or 2 = (3*5+7)/11 (and ten others!).

:SOLUTION:
What we need to do is to bipart the list, search all possible left expressions and right epressions to find a pair with equal value. Each possible arithmetic expression corresponds to a tree, in which leaf nodes are numbers and non-leaf nodes are operators. What's good about this problem is that, all arithmetic operators are binary, so we can build a binary tree to represent arithmetic expressions.

Here we find all equations by brute-forcec search, and print them with a humble print function. It is another interesting problem to print the equation in shortest form.

Use ~split~ defined in [[*P17 (⋆) Split a list into two parts; the length of the first part is given.][P17]] .
#+begin_src lisp :results output
  (defun binary-expresssions (a b)
    (mapcar (lambda (op) (list op a b))
            (list '+ '- '* '/)))

  ;; return a list of all possible arithmetic expressions
  (defun arithmetic-expressions (l)
    (cond
      ((null l) (error "L should be a non-nil list"))
      ((= 1 (length l)) l)
      (t (mapcan (lambda (x)
                   (mapcan (lambda (a)
                             (mapcan (lambda (b) (binary-expresssions a b))
                                     (arithmetic-expressions (cadr x))))
                           (arithmetic-expressions (car x))))
                 (loop for i from 1 to (1- (length l))
                       collect (split l i))))))

  (defun print-arithmetic-expression (exp)
    (cond
      ((null exp))
      ((numberp exp) (format t "~a" exp))
      (t
       (format t "(")
       (print-arithmetic-expression (cadr exp))
       (format t "~a" (car exp))
       (print-arithmetic-expression (caddr exp))
       (format t ")"))))

  (defun print-arithmetic-equation (exp)
    (print-arithmetic-expression (car exp))
    (format t " = ")
    (print-arithmetic-expression (cadr exp))
    (format t "~%"))

  (defun find-arithmetic-equations-aux (left right)
    (mapcan (lambda (exp1)
              (mapcan (lambda (exp2)
                        (when (= (eval exp1) (eval exp2))
                          ;; Bingo! Eval trees directly as lisp expressions.
                          (list (list exp1 exp2))))
                      (arithmetic-expressions right)))
            (arithmetic-expressions left)))

  (defun find-arithmetic-equations (l)
    (let ((exps (loop for i from 1 to (1- (length l))
                      append (apply #'find-arithmetic-equations-aux
                                    (split l i)))))
      (if exps
          (mapc #'print-arithmetic-equation exps)
          (format t "No solution found.~%"))))

  ;; test
  (find-arithmetic-equations '(2 3 5 7 11))
#+end_src

#+RESULTS:
- 2 = (3-(5+(7-11)))
- 2 = (3-((5+7)-11))
- 2 = ((3-5)-(7-11))
- 2 = ((3-(5+7))+11)
- 2 = (((3-5)-7)+11)
- 2 = (((3*5)+7)/11)
- (2*(3-5)) = (7-11)
- (2-(3-(5+7))) = 11
- (2-((3-5)-7)) = 11
- ((2-3)+(5+7)) = 11
- ((2-(3-5))+7) = 11
- (((2-3)+5)+7) = 11

To increase the efficiency of this program, we may save the value of each subexpression to avoid repeated evaluation, but that also means we need to write a wrapper for evaluation rather than use the built-in function ~eval~. What's more, the cost of ~eval~ is not the main cost.
:END:
** P94 (⋆⋆⋆) Generate K-regular simple graphs with N nodes
In a K-regular graph all nodes have degree K; i.e. the number of edges incident to each node is K. How many (non-isomorphic!) 3-regular graphs with 6 nodes are there? See also a table of results.

:SOLUTION:
It is not hard to enumerate all K-regular graphs by brute-force search. The difficulty relies on eliminating isomorphic graphs. It may take too much time to detect for isomorphisms with ~isomorphism-aux-1~ in [[*P85 (⋆⋆) Graph isomorphism][P85]] ... since the structure of K-regular graphs is special, we may use an alternative algorithm for isomorphism testing with better efficiency. For example, a K-regular graph may be decomposed into a sequence of non-overlapped edge cycles, and such a sequence may be used for uniquely identifying a K-regular graph..

Note that generated K-regular simple graph may not be connected, we should remove these bad cases (because my ~isomorphism~ implementation doesn't work on non-connected graphs). For connectivity detection we implement an array-based version of ~connected-components~ here, which works on graph expression form with only number vertices.

Common Lisp doen't provide a built-in ~filter~ function, but it provides a similar helper ~remove-duplicates~. Also use ~range~ from [[*P22 (⋆) Create a list containing all integers within a given range.][P22]], ~combination~ from [[*P26 (⋆⋆) Generate the combinations of K distinct objects chosen from the N elements of a list][P26]].

This program can compute ~K(3,6)~ instantly, however, ~K(3,8)~ will take a few minutes, and actually I am not sure if it correctly enumerated all graphs, but, the answers are correct after all.
#+begin_src lisp
  (defun graph-dfs-2 (a i b)
    (unless (aref b i)
      (setf (aref b i) t)
      (cons i (mapcan (lambda (j) (graph-dfs-2 a j b)) (aref a i)))))

  (defun connected-components-2 (g)
    (let* ((len (length (car g)))
           (a (make-array (1+ len) :initial-element nil))
           (b (make-array (1+ len) :initial-element nil)))
      ;; initialize array of adjacent lists
      (mapc (lambda (e)
              (setf (aref a (car e)) (cons (cadr e) (aref a (car e)))
                    (aref a (cadr e)) (cons (car e) (aref a (cadr e)))))
            (cadr g))
      ;; gather connected components by DFS
      (mapcan (lambda (c) (when c (list c)))
              (loop for i from 1 to len collect (graph-dfs-2 a i b)))))

  (defun connected-p (g)
    (= 1 (length (connected-components-2 g))))

  (defun adjacent-vertices (g v)
    (mapcan (lambda (e)
              (when (member v e)
                (list (if (equal (car e) v)
                          (cadr e)
                          (car e)))))
            (cadr g)))

  ;; Enumerate all K-regular graphs with no duplicates
  (defun k-regular-graphs-aux (vs g k)
    (if (null vs)
        (when (connected-p g) (list g))
        (let* ((v1 (car vs))
               (avs (adjacent-vertices g v1)))
          (cond
            ((= (length avs) k)
             ;; already full, skip to next
             (k-regular-graphs-aux (cdr vs) g k))
            ((< (length avs) k)
             (mapcan
              (lambda (vk)
                ;; add edges and process on the next vertex
                (k-regular-graphs-aux
                 (cdr vs)
                 (list (car g)
                       (append (mapcar (lambda (v2) (list v1 v2)) vk)
                               (cadr g)))
                 k))
              (combination
               (- k (length avs))
               (mapcan (lambda (v2)
                         (when (< (length (adjacent-vertices g v2)) k)
                           (list v2)))
                       (set-difference (remove v1 (car g)) avs)))))))))

  (defun k-regular-graphs (k n)
    (when (and (< k n)
               (= 0 (mod (* k n) 2))) ;; there does not exist K(2m+1, 2n+1)
      (let ((vs (range 1 n)))
        (delete-duplicates
         (k-regular-graphs-aux vs (list vs nil) k)
         :test (lambda (g1 g2) (isomorphism-aux-1 g1 g2 nil))))))

  (k-regular-graphs 3 6)
#+end_src

#+RESULTS:
- (((1 2 3 4 5 6) ((4 6) (3 5) (3 4) (2 3) (2 5) (2 6) (1 4) (1 5) (1 6)))
- ((1 2 3 4 5 6) ((3 4) (3 5) (3 6) (2 4) (2 5) (2 6) (1 4) (1 5) (1 6))))

If we want to test isomorphism on non-connected graphs, we need to test isomorphisms on their connected components. Have ~connected-components~ and ~combinations~ implemented, it will be easy to extend ~isomorphism~ to do so.
:END:
** P95 (⋆⋆) English number words
On financial documents, like cheques, numbers must sometimes be written in full words. Example: 175 must be written as one-seven-five. Write a function (full-words n) to print (non-negative) integer numbers in full words.

:SOLUTION:
#+begin_src lisp :results output
  (defun full-word-aux (n)
    (when (> n 0)
      (cons (mod n 10) (full-word-aux (floor n 10)))))

  (defun full-word (n)
    (let ((coefs (if (= n 0) '(0) (full-word-aux n)))
          (names '("zero" "one" "two" "three" "four"
                   "five" "six" "seven" "eight" "nine")))
      (mapc (lambda (d) (format t "~a-" (nth d names)))
            (reverse (cdr coefs)))
      (format t "~a~%" (nth (car coefs) names))))

  ;; test
  (mapcar #'full-word (list 0 1 7 175))
#+end_src

#+RESULTS:
- zero
- one
- seven
- one-seven-five

:END:
** P96 (⋆⋆) Syntax checker

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p96.gif
[[file:L99.assets/2025-12-06_11-40-11_p96.gif]]

In a certain programming language (Ada) identifiers are defined by the syntax diagram (railroad chart) opposite. Transform the syntax diagram into a system of syntax diagrams which do not contain loops; i.e. which are purely recursive. Using these modified diagrams, write a function ~(identifier str)~ that can check whether or not a given string ~str~ is a legal identifier.

~(identifier str)~ returns t when str is a legal identifier.

:SOLUTION:
The description is strange, if the syntax diagram does not contain a loop, then it is not recursively defined. Besides, it is usually simpler to preserve parsing state rather than using a pure recursive function as checker. After all, Lisp is not good at processing characters, if we want to process a string by character we can only treat it as a sequence type, which provides very limited built-in utilities. To be simple, here we still use ~coerce~ to break it into a list. If we treat it as a sequence, then we will have to check the bound from time to time.

This program itself is dull, what's powerful about recursive functions is that, we can build a syntax checker from a given syntax graph (e. g. an ATN, augmented transition network, which is a graph of syntactic symbols as nodes and transition rules as edges, can be interpreted as a parser function).
#+begin_src lisp
  (defun alpha-or-digit-char-p (ch)
    (or (alpha-char-p ch)
        (digit-char-p ch)))

  (defun identifier-suffix (l)
    (or
     (null l)
     (if (alpha-or-digit-char-p (car l))
         (identifier-suffix (cdr l))
         (and (char= #\_ (car l))
              (cadr l)
              (alpha-or-digit-char-p (cadr l))
              (identifier-suffix (cddr l))))))

  (defun identifier-aux (l)
    (and l
         (alpha-char-p (car l))
         (identifier-suffix (cdr l))))

  (defun identifier (str)
    (identifier-aux (coerce str 'list)))

  ;; test
  (mapcar
   #'identifier
   (list "" "_" "a__b" "a1o1_62_bvs"))
#+end_src

#+RESULTS:
- (NIL NIL NIL T)

:END:
** P97 (⋆⋆) Sudoku
Sudoku puzzles go like this:

#+begin_src ascii
   Problem statement                 Solution

    .  .  4 | 8  .  . | .  1  7      9  3  4 | 8  2  5 | 6  1  7
            |         |                      |         |
    6  7  . | 9  .  . | .  .  .      6  7  2 | 9  1  4 | 8  5  3
            |         |                      |         |
    5  .  8 | .  3  . | .  .  4      5  1  8 | 6  3  7 | 9  2  4
    --------+---------+--------      --------+---------+--------
    3  .  . | 7  4  . | 1  .  .      3  2  5 | 7  4  8 | 1  6  9
            |         |                      |         |
    .  6  9 | .  .  . | 7  8  .      4  6  9 | 1  5  3 | 7  8  2
            |         |                      |         |
    .  .  1 | .  6  9 | .  .  5      7  8  1 | 2  6  9 | 4  3  5
    --------+---------+--------      --------+---------+--------
    1  .  . | .  8  . | 3  .  6      1  9  7 | 5  8  2 | 3  4  6
            |         |                      |         |
    .  .  . | .  .  6 | .  9  1      8  5  3 | 4  7  6 | 2  9  1
            |         |                      |         |
    2  4  . | .  .  1 | 5  .  .      2  4  6 | 3  9  1 | 5  7  8
#+end_src

Every spot in the puzzle belongs to a (horizontal) row and a (vertical) column, as well as to one single 3x3 square (which we call "square" for short). At the beginning, some of the spots carry a single-digit number between 1 and 9. The problem is to fill the missing spots with digits in such a way that every number between 1 and 9 appears exactly once in each row, in each column, and in each square.

:SOLUTION:
Here we don't implement a reader, assume the input is a two-dimensional array.
#+begin_src lisp :results output verbatim :wrap src plaintext
  (defun avail-numbers (puzzle x y)
    (let ((a (make-array 10 :initial-element t)))
      ;; spot
      (let ((left (* 3 (floor x 3)))
            (top (* 3 (floor y 3))))
        (loop for i from left to (+ left 2)
              nconc (loop for j from top to (+ top 2)
                          for k = (aref puzzle i j)
                          when k do (setf (aref a k) nil))))
      ;; column
      (loop for i from 0 to 8 for k = (aref puzzle i y)
            when (and k (aref a k)) do (setf (aref a k) nil))
      ;; row
      (loop for j from 0 to 8 for k = (aref puzzle x j)
            when (and k (aref a k)) do (setf (aref a k) nil))
      ;; collect numbers
      (loop for k from 1 to 9
            when (aref a k) collect k)))

  ;; maybe heuristics here?
  (defun next-hole (puzzle)
    (loop for i from 0 to 8
            thereis (loop for j from 0 to 8
                          when (= 0 (aref puzzle i j))
                            return (cons i j))))

  (defun sudoku-try-xy (puzzle xy k)
    (let ((x (car xy))
          (y (cdr xy)))
      (setf (aref puzzle x y) k)
      (let ((res (sudoku-aux puzzle)))
        (unless res
          (setf (aref puzzle x y) 0))
        res)))

  (defun sudoku-aux (puzzle)
    (let ((xy (next-hole puzzle)))
      (if xy
          (some (lambda (k) (sudoku-try-xy puzzle xy k))
                (avail-numbers puzzle (car xy) (cdr xy)))
          puzzle)))

  (defun sudoku (puzzle)
    (let ((copy (make-array (array-dimensions puzzle))))
      ;; copy input array
      (dotimes (i (array-dimension puzzle 0))
        (dotimes (j (array-dimension puzzle 1))
          (setf (aref copy i j) (aref puzzle i j))))
      (sudoku-aux copy)))

  ;; define a pretty-print handler for puzzle
  ;; you can also use this function for stepwise debugging
  (defun sudoku-print (puzzle)
    (loop for i from 0 upto 8
          do (loop for j from 0 to 8
                   for x = (aref puzzle i j)
                   do (format
                       t (cond
                           ((= 0 j) "~a")
                           ((= 0 (mod j 3)) " | ~a")
                           (t "  ~a"))
                       (if (= 0 x) "." x)))
          do (format
              t (cond
                  ((= i 8) "~%")
                  ((= 0 (mod (1+ i) 3)) "~%--------+---------+--------~%")
                  (t "~%        |         |        ~%")))))

  ;; test
  (let ((puzzle
          (make-array
           '(9 9)
           :initial-contents
           '((0 0 4 8 0 0 0 1 7)
             (6 7 0 9 0 0 0 0 0)
             (5 0 8 0 3 0 0 0 4)
             (3 0 0 7 4 0 1 0 0)
             (0 6 9 0 0 0 7 8 0)
             (0 0 1 0 6 9 0 0 5)
             (1 0 0 0 8 0 3 0 6)
             (0 0 0 0 0 6 0 9 1)
             (2 4 0 0 0 1 5 0 0)))))
    (sudoku-print (sudoku puzzle)))
#+end_src

#+RESULTS:
#+begin_src plaintext
9  3  4 | 8  2  5 | 6  1  7
        |         |
6  7  2 | 9  1  4 | 8  5  3
        |         |
5  1  8 | 6  3  7 | 9  2  4
--------+---------+--------
3  2  5 | 7  4  8 | 1  6  9
        |         |
4  6  9 | 1  5  3 | 7  8  2
        |         |
7  8  1 | 2  6  9 | 4  3  5
--------+---------+--------
1  9  7 | 5  8  2 | 3  4  6
        |         |
8  5  3 | 4  7  6 | 2  9  1
        |         |
2  4  6 | 3  9  1 | 5  7  8
#+end_src

To minimize the cost of recomputing constraints on each cell, we may cache the constraints for each cell locally. These constraints can be checked in O(1) but updated in O(N). However, if we cache the row, column and region constraints separately (because they're shared), we can update each in O(1). Another search strategy for solving sudoku is to always search from the maximum constraint point, e. g. the dancing links.

:END:
** P98 (⋆⋆⋆) Nonograms
Around 1994, a certain kind of puzzles was very popular in England. The "Sunday Telegraph" newspaper wrote: "Nonograms are puzzles from Japan and are currently published each week only in The Sunday Telegraph. Simply use your logic and skill to complete the grid and reveal a picture or diagram." As a Lisp programmer, you are in a better situation: you can have your computer do the work! Just write a little program ;-).
The puzzle goes like this: Essentially, each row and column of a rectangular bitmap is annotated with the respective lengths of its distinct strings of occupied cells. The person who solves the puzzle must complete the bitmap given only these lengths.

#+begin_src ascii
          Problem statement:          :SOLUTION:

          |_|_|_|_|_|_|_|_| 3         |_|X|X|X|_|_|_|_| 3
          |_|_|_|_|_|_|_|_| 2 1       |X|X|_|X|_|_|_|_| 2 1
          |_|_|_|_|_|_|_|_| 3 2       |_|X|X|X|_|_|X|X| 3 2
          |_|_|_|_|_|_|_|_| 2 2       |_|_|X|X|_|_|X|X| 2 2
          |_|_|_|_|_|_|_|_| 6         |_|_|X|X|X|X|X|X| 6
          |_|_|_|_|_|_|_|_| 1 5       |X|_|X|X|X|X|X|_| 1 5
          |_|_|_|_|_|_|_|_| 6         |X|X|X|X|X|X|_|_| 6
          |_|_|_|_|_|_|_|_| 1         |_|_|_|_|X|_|_|_| 1
          |_|_|_|_|_|_|_|_| 2         |_|_|_|X|X|_|_|_| 2
           1 3 1 7 5 3 4 3             1 3 1 7 5 3 4 3
           2 1 5 1                     2 1 5 1
#+end_src

For the example above, the problem can be stated as the two lists ((3) (2 1) (3 2) (2 2) (6) (1 5) (6) (1) (2)) and ((1 2) (3 1) (1 5) (7 1) (5) (3) (4) (3)) which give the "solid" lengths of the rows and columns, top-to-bottom and left-to-right, respectively. Published puzzles are larger than this example, e.g. 25 x 20, and apparently always have unique solutions.

:SOLUTION:
For that 8x9 example we can simply enumerate all possible row states and check it with colums, because there are far less than 9^8 possiblities, but this method can certainly not solve larger boards (e. g. 25 x 20). This problem become hard when we begin to consider how to do backtracking, the problem is that, you can not simply revert an 'X' because it may be already associated to a previous step. Here we use a counter to mark the status of each grid, 0 for not assigned, increase it by 1 if it should be painted, decrease it by 1 if it should be empty.

Here we use DFS strategy: everytime we try to paint a horizontal strip, then we check and paint corresponding vertical strips. The code is very ugly, maybe you can find a more beautiful implementation with better efficiency ...
#+begin_src lisp :results output verbatim :wrap src plaintext
  (defun eat-nth (n l)
    (cond ((= 0 n) (cons (cdr (car l)) (cdr l)))
          ((< 0 n) (cons (car l) (eat-nth (1- n) (cdr l))))))

  (defun eat-nths (ns l &optional (n 0))
    (cond
      ((null ns) l)
      ((= (car ns) n)
       (cons (cdr (car l)) (eat-nths (cdr ns) (cdr l) (1+ n))))
      (t (cons (car l) (eat-nths ns (cdr l) (1+ n))))))

  (defun paint-vertical-strip (board x y h)
    (let ((nrows (nth 0 (array-dimensions board))))
      (when (< 0 x) (decf (aref board (1- x) y)))
      (loop for i from x below (+ x h)
            do (incf (aref board i y)))
      (when (< (+ x h) nrows) (decf (aref board (+ x h) y)))))

  (defun eraze-vertical-strip (board x y h)
    (let ((nrows (nth 0 (array-dimensions board))))
      (when (< 0 x) (incf (aref board (1- x) y)))
      (loop for i from x below (+ x h)
            do (decf (aref board i y)))
      (when (< (+ x h) nrows) (incf (aref board (+ x h) y)))))

  (defun set-vertical-strips (cols board x js)
    (if (null js)
        t
        (let ((nrows (nth 0 (array-dimensions board)))
              (y (car js))
              (h (car (nth (car js) cols))))
          ;; can it be placed here?
          (when (and
                 ;; space at top
                 (or (= 0 x)
                     (and (< 0 x) (<= (aref board (1- x) y) 0)))
                 ;; space at bottom
                 (or (= (+ x h) nrows)
                     (and (< (+ x h) nrows)
                          (<= (aref board (+ x h) y) 0)))
                 ;; inner points are not assigned or painted
                 (loop for i from x below (+ x h)
                       always (<= 0 (aref board i y))))
            ;; paint it
            (paint-vertical-strip board x y h)
            ;; proceed next
            (if (set-vertical-strips cols board x (cdr js))
                t
                ;; if failed in process, recover before ascending.
                (eraze-vertical-strip board x y h))))))

  (defun paint-horizontal-strip (board x y w)
    (let ((ncols (nth 1 (array-dimensions board))))
      (when (< 0 y) (decf (aref board x (1- y))))
      (loop for j from y below (+ y w)
            do (incf (aref board x j)))
      (when (< (+ y w) ncols) (decf (aref board x (+ y w))))))

  (defun eraze-horizontal-strip (board x y w)
    (let ((ncols (nth 1 (array-dimensions board))))
      (when (< 0 y) (incf (aref board x (1- y))))
      (loop for j from y below (+ y w)
            do (decf (aref board x j)))
      (when (< (+ y w) ncols) (incf (aref board x (+ y w))))))

  (defun nanograms-aux-1 (rows cols board x y)
    (let ((w (car (nth x rows)))
          (ncols (nth 1 (array-dimensions board)))
          (js))
      ;; can it be placed here?
      (when (and
             ;; space at left
             (or (= 0 y)
                 (and (< 0 y) (<= (aref board x (1- y)) 0)))
             ;; space at right
             (or (= (+ y w) ncols)
                 (and (< (+ y w) ncols)
                      (<= (aref board x (+ y w)) 0)))
             ;; inner points are not assigned or painted
             (loop for j from y below (+ y w)
                   always (or (< 0 (aref board x j))
                              (when (and (= 0 (aref board x j))
                                         (nth j cols))
                                (setf js (cons j js))))))
        ;; left to right
        (setf js (nreverse js))
        ;; paint it
        (paint-horizontal-strip board x y w)
        ;; check and paint vertical strips
        (if (set-vertical-strips cols board x js)
            ;; succeed, descend on next strip
            (let ((res (nanograms-aux (eat-nth x rows)
                                      (eat-nths js cols)
                                      board x (+ y w 1))))
              (unless res
                ;; if failed, recover before ascending
                (loop for j in js
                      do (let ((h (car (nth j cols))))
                           (eraze-vertical-strip board x j h)))
                (eraze-horizontal-strip board x y w))
              res)
            ;; failed, recover before ascending
            (progn
              (eraze-horizontal-strip board x y w)
              nil)))))

  (defun nanograms-aux (rows cols board x y)
    (let ((nrows (nth 0 (array-dimensions board)))
          (ncols (nth 1 (array-dimensions board))))
      (if (>= x nrows)
          ;; no more rows to try? maybe a solution is found
          (when (every #'null cols) board)
          ;; otherwise, try to fill current row
          (if (null (nth x rows))
              ;; no more available grids in current row, maybe next row?
              (when (loop for j from y below ncols
                          always (>= 0 (aref board x j)))
                (nanograms-aux rows cols board (1+ x) 0))
              ;; current row is not empty, then find a col to try
              (and (< y ncols)
                   (loop for j from y below ncols
                           thereis (and (<= 0 (aref board x j))
                                        (nanograms-aux-1 rows cols board x j))))))))

  (defun nanograms (rows cols)
    (let ((board (make-array (list (length rows) (length cols))
                             :initial-element 0)))
      (loop for j from 0 below (length cols)
              thereis (nanograms-aux rows cols board 0 j))))

  ;; define a pretty-print function for nanograms
  ;; you can also use this function for stepwise debugging
  (defun nanograms-print (rows cols board)
    (loop for i from 0 to (1- (length rows))
          do (loop for j from 0 to (1- (length cols))
                   do (let ((x (aref board i j)))
                        (format t "|~a"
                                (cond ((>= 0 x) "_")
                                      ((< 0 x) "X")))))
             (format t "|")
             (mapc (lambda (x) (format t " ~a" x)) (nth i rows))
             (format t "~%"))
    (let ((n (loop for y in cols maximize (length y))))
      (loop for i from 0 to (1- n)
            do (loop for y in cols
                     do (let ((x (nth i y)))
                          (format t " ~a" (if x x " "))))
               (format t "~%"))))

  ;; test
  (let ((rows '((3) (2 1) (3 2) (2 2) (6) (1 5) (6) (1) (2)))
        (cols '((1 2) (3 1) (1 5) (7 1) (5) (3) (4) (3))))
    (nanograms-print rows cols (nanograms rows cols)))
#+end_src

#+RESULTS:
#+begin_src plaintext
|_|X|X|X|_|_|_|_| 3
|X|X|_|X|_|_|_|_| 2 1
|_|X|X|X|_|_|X|X| 3 2
|_|_|X|X|_|_|X|X| 2 2
|_|_|X|X|X|X|X|X| 6
|X|_|X|X|X|X|X|_| 1 5
|X|X|X|X|X|X|_|_| 6
|_|_|_|_|X|_|_|_| 1
|_|_|_|X|X|_|_|_| 2
 1 3 1 7 5 3 4 3
 2 1 5 1
#+end_src

:END:
** P99 (⋆⋆⋆) Crossword puzzle
Given an empty (or almost empty) framework of a crossword puzzle and a set of words. The problem is to place the words into the framework.

#+DOWNLOADED: https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99.gif
[[file:L99.assets/2025-12-06_11-41-16_p99.gif]]

The particular crossword puzzle is specified in a text file which first lists the words (one word per line) in an arbitrary order. Then, after an empty line, the crossword framework is defined. In this framework specification, an empty character location is represented by a dot (.). In order to make the solution easier, character locations can also contain predefined character values. The puzzle opposite is defined in the file [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99a.dat][p99a.dat]], other examples are [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99b.dat][p99b.dat]] and [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99d.dat][p99d.dat]]. There is also an example of a puzzle ([[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99c.dat][p99c.dat]]) which does not have a solution.

Words are strings (character lists) of at least two characters. A horizontal or vertical sequence of character places in the crossword puzzle framework is called a site. Our problem is to find a compatible way of placing words onto sites.
Hints: (1) The problem is not easy. You will need some time to thoroughly understand it. So, don't give up too early! And remember that the objective is a clean solution, not just a quick-and-dirty hack!
(2) Reading the data file is a tricky problem for which a solution is provided in the file [[https://www.ic.unicamp.br/~meidanis/courses/mc336/problemas-lisp/p99-readfile.lisp][p99-readfile.lisp]]. Use the function read-lines, which returns the words and the grid in a 2-element list.
(3) For efficiency reasons it is important, at least for larger puzzles, to sort the words and the sites in a particular order. For this part of the problem, the solution of P28 may be very helpful.

:SOLUTION:
The explanation problem is not that clear, as fer me, I have these assumptions:
- Assume the input is always a valid word puzzle, we won't check.
- Assume the dot map is always a rectangule, for example, p99a.dat has the last line incomplete, p99b.dat has trailing spaces after several lines, we don't treat them as correct cases. Of course, these problems can be handled if you like.
- Assume the map of words is connected. If it is not connected, you can solve on its connected components independently.
- Assume a word can only be filled into a site in left-to-right or top-to-bottom direction. If reversed directions are allowed, we need to also test reversed words when do filtering.
- Assume there may be redundant words that won't be filled in. That is to say, we don't do global removal when a word is fixed.
- Assume one word may appear twice or more. If each of them can just appear once, then just remove it from ltb when selected.

To solve this problem we need to figure out a appropriate representation of the problem. First we may focus on find out all sites so that we can know where to fill words. We need a structure to find a site's information from its coordinates, information about one site should include its shape (vertical or horizontal) as well as its crossed sites. Here we use a 3D array to do the shape and coordinate transition. This is actually the hardest part of this problem, because the structure is relatively complexed here.

Once the information about sites got organized, we will get a simple constraint satisfaction problem (CSP) to solve. The target is to assign proper values to the sites to satisfy all cross points have no conflicts. CSP with dependency cycles is NP-hard because it is hard to handle circular dependencies. For example, in p99a, there is no circular dependencies, so you can even solve it with a tree DFS without making records on sites (but that won't work for p99b). To solve general cases we need to make records on each site. If you really want to find a solution with a simple deterministic algorithm, you may need to enumerate all possible combinations of sites, then verify all local constraints one by one (I have found this brute-force method in many other people's solutions).

Here we use a constraint propagation algorithm, starting from a point, recursively compute possible options of its constraint sites, finally compute its possible options from its constraints. This algorithm doesn't ensure convergency if there are no fixed points found in one pass. For example, consider there are two parallel solutions that have no conflicts to each other, both can be applied, but differs at cross points, then we won't be able to filter out a concrete solution after propagation. However, this algorithm already worked for all the 4 examples given.

Suppose there is a cycle, we firstly enter that cycle from a point A, and detected the cycle when we are back to A, then A is pruned once. But, actually A will be pruned at least twice, because the way back to A in reversed direction, will also be searched sooner or later as a different propagation path. In both directions, A will preserve its initial status and won't propagate any of its known constraints on that cycle. So when A is finally computed, the constraints of A are not sufficiently pruned yet, because the pruning order matters here. Compared to AC-3 algorithm, AC-3 use a queue rather than a stack to determine the computing order, which also won't ensure global convergency.

Even if the constraint propagation didn't converge,  the result is usually with a much smaller size to compute. So I think this algorithm is still useful. That means, the remaining work can be done by brute-force searching in much less time.

These small optimizations are applied: (not meaningful but I just did them)
- We may only cache information about each site at the left-top end of it to avoid repeated travel. For other cells in the same site, we only cache the position of the left-top end. This allows us to do O(N) travel to build the sitemap (a trival travel with segment search takes O(N^2)).
- We build a hash table ~ltb~ which classify words by length, this helps us pick words faster, especially for smaller problems.

#+begin_src lisp :results output verbatim :wrap src plaintext
  (defun read-puzzle (in)
    (let* ((dict (loop for line = (read-line in nil nil)
                       while (not (zerop (length line)))
                       collect line))
           (pre-dotmap (loop for line = (read-line in nil nil)
                             while line collect line)))
      (values dict
              (let ((h (length pre-dotmap))
                    (w (length (car pre-dotmap))))
                (make-array (list h w) :initial-contents pre-dotmap)))))

  (defun vlead-p (dotmap x y)
    (or (= 0 x)
        (equal #\space (aref dotmap (1- x) y))))

  (defun vertical-site (sitemap dotmap x y)
    (let ((site (aref sitemap 0 x y)))
      (cond
        ((null site) nil)
        ((consp site) site)
        (t
         (if (vlead-p dotmap x y)
             (let ((end
                     (loop for i from (1+ x) below (array-dimension dotmap 0)
                             thereis (when (equal #\space (aref dotmap i y))
                                       (1- i))
                           finally (return (1- i)))))
               (setf (aref sitemap 0 x y)
                     (unless (= x end) (list end))))
             (let ((bgn (aref sitemap 0 (1- x) y)))
               (setf (aref sitemap 0 x y)
                     (cond ((consp bgn) (1- x))
                           ((numberp bgn) bgn)))))))))

  (defun hlead-p (dotmap x y)
    (or (= 0 y)
        (equal #\space (aref dotmap x (1- y)))))

  (defun horizontal-site (sitemap dotmap x y)
    (let ((site (aref sitemap 1 x y)))
      (cond
        ((null site) nil)
        ((consp site) site)
        (t
         (if (hlead-p dotmap x y)
             (let ((end
                     (loop for j from (1+ y) below (array-dimension dotmap 1)
                             thereis (when (equal #\space (aref dotmap x j))
                                       (1- j))
                           finally (return (1- j)))))
               (setf (aref sitemap 1 x y)
                     (unless (= y end) (list end))))
             (let ((bgn (aref sitemap 1 x (1- y))))
               (setf (aref sitemap 1 x y)
                     (cond ((consp bgn) (1- y))
                           ((numberp bgn) bgn)))))))))

  (defun find-horizontal-crosses (sitemap bgn end y)
    (loop for k from bgn to end
          for a = (aref sitemap 1 k y)
          nconc (cond ((numberp a) (list (cons k a)))
                      ((consp a) (list (cons k y))))))

  (defun find-vertical-crosses (sitemap bgn end x)
    (loop for k from bgn to end
          for a = (aref sitemap 0 x k)
          nconc (cond ((numberp a) (list (cons a k)))
                      ((consp a) (list (cons x k))))))

  (defun build-sitemap (dotmap)
    (let ((h (array-dimension dotmap 0))
          (w (array-dimension dotmap 1))
          (sites))
      (let ((sitemap (make-array (cons 2 (array-dimensions dotmap))
                                 :initial-element t)))
        ;; scanning sites
        (loop for i from 0 below h
              do (loop for j from 0 below w
                       do (when (not (equal #\space (aref dotmap i j)))
                            (horizontal-site sitemap dotmap i j)
                            (vertical-site sitemap dotmap i j))))
        ;; associate vertical sites
        (loop for j from 0 below w
              do (loop for i from 0 below h
                       for site = (aref sitemap 0 i j)
                       do (when (consp site)
                            (rplacd site (find-horizontal-crosses
                                          sitemap i (car site) j))
                            (push (list 0 i j) sites)
                            (setf i (car site)))))
        ;; assocaite horizontal sites
        (loop for i from 0 below h
              do (loop for j from 0 below w
                       for site = (aref sitemap 1 i j)
                       do (when (consp site)
                            (rplacd site (find-vertical-crosses
                                          sitemap j (car site) i))
                            (push (list 1 i j) sites)
                            (setf j (car site)))))
        (values sitemap sites))))

  (defun build-length-table (dict)
    (let ((h (make-hash-table)))
      (mapc (lambda (w)
              (let ((len (length w)))
                (setf (gethash len h)
                      (cons w (gethash len h)))))
            dict)
      h))

  ;; each filter in form (chs . pos)
  ;; if we apply them iteratively, the efficiency may be better
  (defun filter-words (dict filters)
    (mapcan (lambda (w)
              (when (loop for filter in filters
                          always (member (aref w (cdr filter))
                                         (car filter)))
                (list w)))
            dict))

  (defun avail-chars (dict pos)
    (remove-duplicates
     (mapcar (lambda (w) (aref w pos)) dict)))

  (defun initial-filters (sitemap dotmap d x y)
    (if (zerop d)
        (loop for i from x to (car (aref sitemap d x y))
              for ch = (aref dotmap i y)
              when (not (equal #\. ch))
                collect (cons (list ch) i))
        (loop for j from y to (car (aref sitemap d x y))
              for ch = (aref dotmap x j)
              when (not (equal #\. ch))
                collect (cons (list ch) j))))

  (defun build-wordmap (ltb sitemap dotmap)
    (let ((wordmap (make-array (array-dimensions sitemap)))
          (h (array-dimension sitemap 1))
          (w (array-dimension sitemap 2)))
      (loop for i from 0 below h
            do (loop for j from 0 below w
                     do (progn
                          (let ((a (aref sitemap 0 i j)))
                            (when (consp a)
                              (setf (aref wordmap 0 i j)
                                    (filter-words
                                     (gethash (1+ (- (car a) i)) ltb)
                                     (initial-filters
                                      sitemap dotmap 0 i j)))))
                          (let ((a (aref sitemap 1 i j)))
                            (when (consp a)
                              (setf (aref wordmap 1 i j)
                                    (filter-words
                                     (gethash (1+ (- (car a) j)) ltb)
                                     (initial-filters
                                      sitemap dotmap 1 i j))))))))
      wordmap))

  ;; check if a site is satisfied with current wordmap
  (defun site-satisfied-p (wordmap sitemap site)
    (let ((d (car site))
          (x (cadr site))
          (y (caddr site)))
      (let ((w (car (aref wordmap d x y))))
        (if (zerop d)
            (loop for a in (cdr (aref sitemap d x y))
                  for cw = (car (aref wordmap (- 1 d) (car a) (cdr a)))
                  always (char= (aref w (- (car a) x))
                                (aref cw (- y (cdr a)))))
            (loop for a in (cdr (aref sitemap d x y))
                  for cw = (car (aref wordmap (- 1 d) (car a) (cdr a)))
                  always (char= (aref w (- (cdr a) y))
                                (aref cw (- x (car a)))))))))

  (defun wordmap-satisfied-p (wordmap sitemap sites)
    (loop for site in sites
          always (site-satisfied-p wordmap sitemap site)))

  ;; enumerate-and-verify, very very slow
  (defun crossword-brute (wordmap sitemap sites dep)
    (if (null dep)
        (when (wordmap-satisfied-p wordmap sitemap sites)
          wordmap)
        (let ((site (car dep)))
          (let ((d (car site))
                (x (cadr site))
                (y (caddr site)))
            (loop with len = (length (aref wordmap d x y))
                  for _ from 0 below len
                    thereis
                    (crossword-brute wordmap sitemap sites (cdr dep))
                  do (let ((ws (aref wordmap d x y)))
                       ;; rotate wordlist
                       (setf (aref wordmap d x y)
                             (nconc (cdr ws) (cons (car ws) nil)))))))))

  ;; constraint propagation
  (defun crossword-cp (wordmap sitemap path)
    (let* ((site (car path))
           (d (car site))
           (x (cadr site))
           (y (caddr site)))
      (setf (aref wordmap d x y)
            (filter-words
             (aref wordmap d x y)
             (loop for a in (cdr (aref sitemap d x y))
                   for xsite = (list (- 1 d) (car a) (cdr a))
                   collect
                   (let* ((ow (aref wordmap (- 1 d) (car a) (cdr a)))
                          (ws (if (or (<= (length ow) 1)
                                      (member xsite path :test #'equal))
                                  ;; prune fixed points and cycles
                                  ow
                                  ;; branch down recursively
                                  (crossword-cp
                                   wordmap sitemap (cons xsite path)))))
                     (if (zerop d)
                         (cons (avail-chars ws (- y (cdr a)))
                               (- (car a) x))
                         (cons (avail-chars ws (- x (car a)))
                               (- (cdr a) y)))))))))

  (defun crossword (filename)
    (with-open-file (f filename)
      (multiple-value-bind (dict dotmap)
          (read-puzzle f)
        (multiple-value-bind (sitemap sites)
            (build-sitemap dotmap)
          (let* ((ltb (build-length-table dict))
                 (wordmap (build-wordmap ltb sitemap dotmap)))
            (let ((site (car sites)))
              (when (crossword-cp wordmap sitemap (list site))
                (crossword-brute wordmap sitemap sites sites))))))))

  (defun print-wordmap (wordmap)
    (if (null wordmap)
        (format t "No Solution Found!~%")
        (let ((dotmap (make-array (cdr (array-dimensions wordmap))
                                  :initial-element #\space))
              (h (array-dimension wordmap 1))
              (w (array-dimension wordmap 2)))
          (loop for i from 0 below h
                do (loop for j from 0 below w
                         for vw = (aref wordmap 0 i j)
                         for hw = (aref wordmap 1 i j)
                         do (progn
                              (when (consp vw)
                                (loop with cw = (car vw)
                                      for k from 0 below (length cw)
                                      do (setf (aref dotmap (+ i k) j)
                                               (aref cw k))))
                              (when (consp hw)
                                (loop with cw = (car hw)
                                      for k from 0 below (length cw)
                                      do (setf (aref dotmap i (+ j k))
                                               (aref cw k)))))))
          (loop for i from 0 below h
                do (loop for j from 0 below w
                         do (format t "~a " (aref dotmap i j)))
                   (format t "~%"))))
    (format t "~%"))

  ;; test
  (progn
    (print-wordmap (crossword "p99a.dat"))
    (print-wordmap (crossword "p99b.dat"))
    (print-wordmap (crossword "p99c.dat"))
    (print-wordmap (crossword "p99d.dat"))
    )
#+end_src

#+RESULTS:
#+begin_src plaintext
P R O L O G     E 
E   N     N     M 
R   L I N U X   A 
L   I   F   M A C 
    N   S Q L   S 
  W E B           

P   T U R K M E N E N   T R A U B E N Z U C K E R 
R   A               E   A                   R   I 
O   T E M P E R A M E N T       F O R T U N A   V 
T   T               F               E       N   I 
E G E R I A   Z E U S   T   S A M P A N     K   E 
K   R                   E   T       U       E   R 
T   S   W A L Z E R     L I A N E   M A D O N N A 
O   A   A     A     T A L   N       U       K     
R E L I G I O N     R       N       R   T I A R A 
A   L   G     K     U       I   S       I   S     
T       O           E   S T O I K E R   L   S     
  G R A N A T       F       L   E     O S T E N   
    E           S   F           L       I       C 
    G     T U R K M E N E N   V E N D E T T A   H 
    I   B   S   R   L           T           T   R 
  T E L L   A   U     H   S T E T T I N     T   O 
S   T   A   M   P     I       T         T A T   N 
E   E   S   B   E   B R I E F T A U B E     A   O 
L I A N E   A   L     T       A         S   K   G 
U           R         E   T A L   M     E   T   R 
N   A L L E N S T E I N     N     I     R   I   A 
D   L         T             K     S     B   O   P 
E O S I N     U S A M B A R A   S E R B I E N   H 
    E         H             R     R     E       I 
S T A N N I O L       M E L A S S E     N O N N E 

No Solution Found!

B A R K A S S E   R E A K T I O N   S I D E R I T 
E       N         I       R         I   E       R 
T   F   A   A U S T R A L I E N     G   K       A 
E R R A T E N     T       A   A   B E D A N K E N 
I   A   O   G     E   A   N   T     L   D   R   I 
L   G   M   O   T R A N I G   A         E   A   G 
I   M   I   L         P   E R L A S S E N   W     
G   E   E K A R T E   A   L   I   O     T   A   U 
E   N     A     E     S       T   M         T   N 
N E N N E R     N E S S E L   A   M   A Z E T A T 
          O     T     E   E   E   E   R     E   E 
G E L E I S E   A     N   U   T E R R I E R     R 
R         S     K         M           E         S 
I   S     E R R E G E R   U E B E R A L L       T 
A   A           L         N         G           A 
N E S S E L   A   H A E N D E L   V E R G E B E N 
G   T         L   A                 N   A       D 
E   A   B U L L A U G E N       M   T   S         
L   N         E   S     E       E   U   S E S A M 
    D         N     O S T E R E I   R   E       A 
O B E R H A U S E N     Z       S         I     N 
R   R         T     L     B E S T E L L E N     A 
A     V E R B E R G E N   A     E         N     G 
D             I     N     N     R         E     E 
E R L A S S E N     A F R I K A N E R   A N K E R 

#+end_src

:END:
* One Last Step
Congratulations! Actually there are just 88 problems in total, but I think these should be enough to entertain you.

Now, shutdown your computer and go to sleep!
